// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: x_proxy.proto

/*
	Package v2 is a generated protocol buffer package.

	It is generated from these files:
		x_proxy.proto

	It has these top-level messages:
		XProxy
		Rds
		StreamFilter
*/
package v2

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import envoy_api_v2_core2 "github.com/envoyproxy/go-control-plane/envoy/api/v2/core"
import envoy_api_v21 "github.com/envoyproxy/go-control-plane/envoy/api/v2"
import envoy_config_filter_accesslog_v2 "github.com/envoyproxy/go-control-plane/envoy/config/filter/accesslog/v2"
import envoy_type1 "github.com/envoyproxy/go-control-plane/envoy/type"
import _ "github.com/golang/protobuf/ptypes/duration"
import google_protobuf "github.com/gogo/protobuf/types"
import _ "github.com/lyft/protoc-gen-validate/validate"
import _ "github.com/gogo/protobuf/gogoproto"

import time "time"

import types "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type XProxy_Protocol int32

const (
	// For every protocol
	X XProxy_Protocol = 0
	// protocol between sidecars
	Http2 XProxy_Protocol = 1
)

var XProxy_Protocol_name = map[int32]string{
	0: "X",
	1: "Http2",
}
var XProxy_Protocol_value = map[string]int32{
	"X":     0,
	"Http2": 1,
}

func (x XProxy_Protocol) String() string {
	return proto.EnumName(XProxy_Protocol_name, int32(x))
}
func (XProxy_Protocol) EnumDescriptor() ([]byte, []int) { return fileDescriptorXProxy, []int{0, 0} }

type XProxy_Tracing_OperationName int32

const (
	// The XProxy listener is used for ingress/incoming requests.
	INGRESS XProxy_Tracing_OperationName = 0
	// The XProxy listener is used for egress/outgoing requests.
	EGRESS XProxy_Tracing_OperationName = 1
)

var XProxy_Tracing_OperationName_name = map[int32]string{
	0: "INGRESS",
	1: "EGRESS",
}
var XProxy_Tracing_OperationName_value = map[string]int32{
	"INGRESS": 0,
	"EGRESS":  1,
}

func (x XProxy_Tracing_OperationName) String() string {
	return proto.EnumName(XProxy_Tracing_OperationName_name, int32(x))
}
func (XProxy_Tracing_OperationName) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorXProxy, []int{0, 0, 0}
}

// [#comment:next free field: 23]
type XProxy struct {
	// Supplies the x's real protocol.
	XProtocol string `protobuf:"bytes,1,opt,name=x_protocol,json=xProtocol,proto3" json:"x_protocol,omitempty"`
	// The human readable prefix to use when emitting statistics for the
	// connection manager. See the :ref:`statistics documentation <config_http_conn_man_stats>` for
	// more information.
	StatPrefix string `protobuf:"bytes,2,opt,name=stat_prefix,json=statPrefix,proto3" json:"stat_prefix,omitempty"`
	// Types that are valid to be assigned to RouteSpecifier:
	//	*XProxy_Rds
	//	*XProxy_RouteConfig
	RouteSpecifier     isXProxy_RouteSpecifier `protobuf_oneof:"route_specifier"`
	DownstreamProtocol XProxy_Protocol         `protobuf:"varint,5,opt,name=downstream_protocol,json=downstreamProtocol,proto3,enum=envoy.config.filter.network.x_proxy.v2.XProxy_Protocol" json:"downstream_protocol,omitempty"`
	UpstreamProtocol   XProxy_Protocol         `protobuf:"varint,6,opt,name=upstream_protocol,json=upstreamProtocol,proto3,enum=envoy.config.filter.network.x_proxy.v2.XProxy_Protocol" json:"upstream_protocol,omitempty"`
	// A list of individual HTTP filters that make up the filter chain for
	// requests made to the connection manager. Order matters as the filters are
	// processed sequentially as request events happen.
	StreamFilters []*StreamFilter `protobuf:"bytes,7,rep,name=stream_filters,json=streamFilters" json:"stream_filters,omitempty"`
	// A list of meta used to add to http2 header
	MetasToAddToHeader []string `protobuf:"bytes,8,rep,name=metas_to_add_to_header,json=metasToAddToHeader" json:"metas_to_add_to_header,omitempty"`
	// Presence of the object defines whether the connection manager
	// emits :ref:`tracing <arch_overview_tracing>` data to the :ref:`configured tracing provider
	// <envoy_api_msg_config.trace.v2.Tracing>`.
	Tracing *XProxy_Tracing `protobuf:"bytes,9,opt,name=tracing" json:"tracing,omitempty"`
	// An optional override that the connection manager will write to the server
	// header in responses. If not set, the default is *envoy*.
	ServerName string `protobuf:"bytes,10,opt,name=server_name,json=serverName,proto3" json:"server_name,omitempty"`
	// The idle timeout for connections managed by the connection manager. The
	// idle timeout is defined as the period in which there are no active
	// requests. If not set, there is no idle timeout. When the idle timeout is
	// reached the connection will be closed. If the connection is an HTTP/2
	// connection a drain sequence will occur prior to closing the connection. See
	// :ref:`drain_timeout
	// <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.drain_timeout>`.
	IdleTimeout *time.Duration `protobuf:"bytes,11,opt,name=idle_timeout,json=idleTimeout,stdduration" json:"idle_timeout,omitempty"`
	// The time that Envoy will wait between sending an HTTP/2 “shutdown
	// notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
	// This is used so that Envoy provides a grace period for new streams that
	// race with the final GOAWAY frame. During this grace period, Envoy will
	// continue to accept new streams. After the grace period, a final GOAWAY
	// frame is sent and Envoy will start refusing new streams. Draining occurs
	// both when a connection hits the idle timeout or during general server
	// draining. The default grace period is 5000 milliseconds (5 seconds) if this
	// option is not specified.
	DrainTimeout *time.Duration `protobuf:"bytes,12,opt,name=drain_timeout,json=drainTimeout,stdduration" json:"drain_timeout,omitempty"`
	// Configuration for :ref:`HTTP access logs <arch_overview_access_logs>`
	// emitted by the connection manager.
	AccessLog []*envoy_config_filter_accesslog_v2.AccessLog `protobuf:"bytes,13,rep,name=access_log,json=accessLog" json:"access_log,omitempty"`
}

func (m *XProxy) Reset()                    { *m = XProxy{} }
func (m *XProxy) String() string            { return proto.CompactTextString(m) }
func (*XProxy) ProtoMessage()               {}
func (*XProxy) Descriptor() ([]byte, []int) { return fileDescriptorXProxy, []int{0} }

type isXProxy_RouteSpecifier interface {
	isXProxy_RouteSpecifier()
	MarshalTo([]byte) (int, error)
	Size() int
}

type XProxy_Rds struct {
	Rds *Rds `protobuf:"bytes,3,opt,name=rds,oneof"`
}
type XProxy_RouteConfig struct {
	RouteConfig *envoy_api_v21.RouteConfiguration `protobuf:"bytes,4,opt,name=route_config,json=routeConfig,oneof"`
}

func (*XProxy_Rds) isXProxy_RouteSpecifier()         {}
func (*XProxy_RouteConfig) isXProxy_RouteSpecifier() {}

func (m *XProxy) GetRouteSpecifier() isXProxy_RouteSpecifier {
	if m != nil {
		return m.RouteSpecifier
	}
	return nil
}

func (m *XProxy) GetXProtocol() string {
	if m != nil {
		return m.XProtocol
	}
	return ""
}

func (m *XProxy) GetStatPrefix() string {
	if m != nil {
		return m.StatPrefix
	}
	return ""
}

func (m *XProxy) GetRds() *Rds {
	if x, ok := m.GetRouteSpecifier().(*XProxy_Rds); ok {
		return x.Rds
	}
	return nil
}

func (m *XProxy) GetRouteConfig() *envoy_api_v21.RouteConfiguration {
	if x, ok := m.GetRouteSpecifier().(*XProxy_RouteConfig); ok {
		return x.RouteConfig
	}
	return nil
}

func (m *XProxy) GetDownstreamProtocol() XProxy_Protocol {
	if m != nil {
		return m.DownstreamProtocol
	}
	return X
}

func (m *XProxy) GetUpstreamProtocol() XProxy_Protocol {
	if m != nil {
		return m.UpstreamProtocol
	}
	return X
}

func (m *XProxy) GetStreamFilters() []*StreamFilter {
	if m != nil {
		return m.StreamFilters
	}
	return nil
}

func (m *XProxy) GetMetasToAddToHeader() []string {
	if m != nil {
		return m.MetasToAddToHeader
	}
	return nil
}

func (m *XProxy) GetTracing() *XProxy_Tracing {
	if m != nil {
		return m.Tracing
	}
	return nil
}

func (m *XProxy) GetServerName() string {
	if m != nil {
		return m.ServerName
	}
	return ""
}

func (m *XProxy) GetIdleTimeout() *time.Duration {
	if m != nil {
		return m.IdleTimeout
	}
	return nil
}

func (m *XProxy) GetDrainTimeout() *time.Duration {
	if m != nil {
		return m.DrainTimeout
	}
	return nil
}

func (m *XProxy) GetAccessLog() []*envoy_config_filter_accesslog_v2.AccessLog {
	if m != nil {
		return m.AccessLog
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*XProxy) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _XProxy_OneofMarshaler, _XProxy_OneofUnmarshaler, _XProxy_OneofSizer, []interface{}{
		(*XProxy_Rds)(nil),
		(*XProxy_RouteConfig)(nil),
	}
}

func _XProxy_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*XProxy)
	// route_specifier
	switch x := m.RouteSpecifier.(type) {
	case *XProxy_Rds:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Rds); err != nil {
			return err
		}
	case *XProxy_RouteConfig:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RouteConfig); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("XProxy.RouteSpecifier has unexpected type %T", x)
	}
	return nil
}

func _XProxy_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*XProxy)
	switch tag {
	case 3: // route_specifier.rds
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Rds)
		err := b.DecodeMessage(msg)
		m.RouteSpecifier = &XProxy_Rds{msg}
		return true, err
	case 4: // route_specifier.route_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(envoy_api_v21.RouteConfiguration)
		err := b.DecodeMessage(msg)
		m.RouteSpecifier = &XProxy_RouteConfig{msg}
		return true, err
	default:
		return false, nil
	}
}

func _XProxy_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*XProxy)
	// route_specifier
	switch x := m.RouteSpecifier.(type) {
	case *XProxy_Rds:
		s := proto.Size(x.Rds)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *XProxy_RouteConfig:
		s := proto.Size(x.RouteConfig)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type XProxy_Tracing struct {
	// The span name will be derived from this field.
	OperationName XProxy_Tracing_OperationName `protobuf:"varint,1,opt,name=operation_name,json=operationName,proto3,enum=envoy.config.filter.network.x_proxy.v2.XProxy_Tracing_OperationName" json:"operation_name,omitempty"`
	// A list of meta used to create tags for the active span
	RequestMetasForTags []string `protobuf:"bytes,2,rep,name=request_metas_for_tags,json=requestMetasForTags" json:"request_metas_for_tags,omitempty"`
	// [#not-implemented-hide:]
	// Target percentage of requests managed by this HTTP connection manager that will be force
	// traced if the :ref:`x-client-trace-id <config_http_conn_man_headers_x-client-trace-id>`
	// header is set. This field is a direct analog for the runtime variable
	// 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
	// <config_http_conn_man_runtime>`.
	// Default: 100%
	ClientSampling *envoy_type1.Percent `protobuf:"bytes,3,opt,name=client_sampling,json=clientSampling" json:"client_sampling,omitempty"`
	// [#not-implemented-hide:]
	// Target percentage of requests managed by this HTTP connection manager that will be randomly
	// selected for trace generation, if not requested by the client or not forced. This field is
	// a direct analog for the runtime variable 'tracing.random_sampling' in the
	// :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
	// Default: 100%
	RandomSampling *envoy_type1.Percent `protobuf:"bytes,4,opt,name=random_sampling,json=randomSampling" json:"random_sampling,omitempty"`
	// [#not-implemented-hide:]
	// Target percentage of requests managed by this HTTP connection manager that will be traced
	// after all other sampling checks have been applied (client-directed, force tracing, random
	// sampling). This field functions as an upper limit on the total configured sampling rate. For
	// instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
	// of client requests with the appropriate headers to be force traced. This field is a direct
	// analog for the runtime variable 'tracing.global_enabled' in the
	// :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
	// Default: 100%
	OverallSampling *envoy_type1.Percent `protobuf:"bytes,5,opt,name=overall_sampling,json=overallSampling" json:"overall_sampling,omitempty"`
}

func (m *XProxy_Tracing) Reset()                    { *m = XProxy_Tracing{} }
func (m *XProxy_Tracing) String() string            { return proto.CompactTextString(m) }
func (*XProxy_Tracing) ProtoMessage()               {}
func (*XProxy_Tracing) Descriptor() ([]byte, []int) { return fileDescriptorXProxy, []int{0, 0} }

func (m *XProxy_Tracing) GetOperationName() XProxy_Tracing_OperationName {
	if m != nil {
		return m.OperationName
	}
	return INGRESS
}

func (m *XProxy_Tracing) GetRequestMetasForTags() []string {
	if m != nil {
		return m.RequestMetasForTags
	}
	return nil
}

func (m *XProxy_Tracing) GetClientSampling() *envoy_type1.Percent {
	if m != nil {
		return m.ClientSampling
	}
	return nil
}

func (m *XProxy_Tracing) GetRandomSampling() *envoy_type1.Percent {
	if m != nil {
		return m.RandomSampling
	}
	return nil
}

func (m *XProxy_Tracing) GetOverallSampling() *envoy_type1.Percent {
	if m != nil {
		return m.OverallSampling
	}
	return nil
}

type Rds struct {
	// Configuration source specifier for RDS.
	ConfigSource envoy_api_v2_core2.ConfigSource `protobuf:"bytes,1,opt,name=config_source,json=configSource" json:"config_source"`
	// The name of the route configuration. This name will be passed to the RDS
	// API. This allows an Envoy configuration with multiple HTTP listeners (and
	// associated HTTP connection manager filters) to use different route
	// configurations.
	RouteConfigName string `protobuf:"bytes,2,opt,name=route_config_name,json=routeConfigName,proto3" json:"route_config_name,omitempty"`
}

func (m *Rds) Reset()                    { *m = Rds{} }
func (m *Rds) String() string            { return proto.CompactTextString(m) }
func (*Rds) ProtoMessage()               {}
func (*Rds) Descriptor() ([]byte, []int) { return fileDescriptorXProxy, []int{1} }

func (m *Rds) GetConfigSource() envoy_api_v2_core2.ConfigSource {
	if m != nil {
		return m.ConfigSource
	}
	return envoy_api_v2_core2.ConfigSource{}
}

func (m *Rds) GetRouteConfigName() string {
	if m != nil {
		return m.RouteConfigName
	}
	return ""
}

type StreamFilter struct {
	// The name of the filter to instantiate. The name must match a supported
	// filter. The built-in filters are:
	//
	// [#comment:TODO(mattklein123): Auto generate the following list]
	// * :ref:`envoy.buffer <config_http_filters_buffer>`
	// * :ref:`envoy.cors <config_http_filters_cors>`
	// * :ref:`envoy.fault <config_http_filters_fault_injection>`
	// * :ref:`envoy.gzip <config_http_filters_gzip>`
	// * :ref:`envoy.http_dynamo_filter <config_http_filters_dynamo>`
	// * :ref:`envoy.grpc_http1_bridge <config_http_filters_grpc_bridge>`
	// * :ref:`envoy.grpc_json_transcoder <config_http_filters_grpc_json_transcoder>`
	// * :ref:`envoy.grpc_web <config_http_filters_grpc_web>`
	// * :ref:`envoy.health_check <config_http_filters_health_check>`
	// * :ref:`envoy.header_to_metadata <config_http_filters_header_to_metadata>`
	// * :ref:`envoy.ip_tagging <config_http_filters_ip_tagging>`
	// * :ref:`envoy.lua <config_http_filters_lua>`
	// * :ref:`envoy.rate_limit <config_http_filters_rate_limit>`
	// * :ref:`envoy.router <config_http_filters_router>`
	// * :ref:`envoy.squash <config_http_filters_squash>`
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Filter specific configuration which depends on the filter being
	// instantiated. See the supported filters for further documentation.
	Config *google_protobuf.Struct `protobuf:"bytes,2,opt,name=config" json:"config,omitempty"`
}

func (m *StreamFilter) Reset()                    { *m = StreamFilter{} }
func (m *StreamFilter) String() string            { return proto.CompactTextString(m) }
func (*StreamFilter) ProtoMessage()               {}
func (*StreamFilter) Descriptor() ([]byte, []int) { return fileDescriptorXProxy, []int{2} }

func (m *StreamFilter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *StreamFilter) GetConfig() *google_protobuf.Struct {
	if m != nil {
		return m.Config
	}
	return nil
}

func init() {
	proto.RegisterType((*XProxy)(nil), "envoy.config.filter.network.x_proxy.v2.XProxy")
	proto.RegisterType((*XProxy_Tracing)(nil), "envoy.config.filter.network.x_proxy.v2.XProxy.Tracing")
	proto.RegisterType((*Rds)(nil), "envoy.config.filter.network.x_proxy.v2.Rds")
	proto.RegisterType((*StreamFilter)(nil), "envoy.config.filter.network.x_proxy.v2.StreamFilter")
	proto.RegisterEnum("envoy.config.filter.network.x_proxy.v2.XProxy_Protocol", XProxy_Protocol_name, XProxy_Protocol_value)
	proto.RegisterEnum("envoy.config.filter.network.x_proxy.v2.XProxy_Tracing_OperationName", XProxy_Tracing_OperationName_name, XProxy_Tracing_OperationName_value)
}
func (m *XProxy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *XProxy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.XProtocol) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintXProxy(dAtA, i, uint64(len(m.XProtocol)))
		i += copy(dAtA[i:], m.XProtocol)
	}
	if len(m.StatPrefix) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintXProxy(dAtA, i, uint64(len(m.StatPrefix)))
		i += copy(dAtA[i:], m.StatPrefix)
	}
	if m.RouteSpecifier != nil {
		nn1, err := m.RouteSpecifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if m.DownstreamProtocol != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintXProxy(dAtA, i, uint64(m.DownstreamProtocol))
	}
	if m.UpstreamProtocol != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintXProxy(dAtA, i, uint64(m.UpstreamProtocol))
	}
	if len(m.StreamFilters) > 0 {
		for _, msg := range m.StreamFilters {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintXProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MetasToAddToHeader) > 0 {
		for _, s := range m.MetasToAddToHeader {
			dAtA[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Tracing != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintXProxy(dAtA, i, uint64(m.Tracing.Size()))
		n2, err := m.Tracing.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.ServerName) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintXProxy(dAtA, i, uint64(len(m.ServerName)))
		i += copy(dAtA[i:], m.ServerName)
	}
	if m.IdleTimeout != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintXProxy(dAtA, i, uint64(types.SizeOfStdDuration(*m.IdleTimeout)))
		n3, err := types.StdDurationMarshalTo(*m.IdleTimeout, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.DrainTimeout != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintXProxy(dAtA, i, uint64(types.SizeOfStdDuration(*m.DrainTimeout)))
		n4, err := types.StdDurationMarshalTo(*m.DrainTimeout, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.AccessLog) > 0 {
		for _, msg := range m.AccessLog {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintXProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *XProxy_Rds) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Rds != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintXProxy(dAtA, i, uint64(m.Rds.Size()))
		n5, err := m.Rds.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *XProxy_RouteConfig) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RouteConfig != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintXProxy(dAtA, i, uint64(m.RouteConfig.Size()))
		n6, err := m.RouteConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *XProxy_Tracing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *XProxy_Tracing) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OperationName != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintXProxy(dAtA, i, uint64(m.OperationName))
	}
	if len(m.RequestMetasForTags) > 0 {
		for _, s := range m.RequestMetasForTags {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.ClientSampling != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintXProxy(dAtA, i, uint64(m.ClientSampling.Size()))
		n7, err := m.ClientSampling.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.RandomSampling != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintXProxy(dAtA, i, uint64(m.RandomSampling.Size()))
		n8, err := m.RandomSampling.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.OverallSampling != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintXProxy(dAtA, i, uint64(m.OverallSampling.Size()))
		n9, err := m.OverallSampling.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *Rds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rds) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintXProxy(dAtA, i, uint64(m.ConfigSource.Size()))
	n10, err := m.ConfigSource.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	if len(m.RouteConfigName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintXProxy(dAtA, i, uint64(len(m.RouteConfigName)))
		i += copy(dAtA[i:], m.RouteConfigName)
	}
	return i, nil
}

func (m *StreamFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintXProxy(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Config != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintXProxy(dAtA, i, uint64(m.Config.Size()))
		n11, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func encodeVarintXProxy(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *XProxy) Size() (n int) {
	var l int
	_ = l
	l = len(m.XProtocol)
	if l > 0 {
		n += 1 + l + sovXProxy(uint64(l))
	}
	l = len(m.StatPrefix)
	if l > 0 {
		n += 1 + l + sovXProxy(uint64(l))
	}
	if m.RouteSpecifier != nil {
		n += m.RouteSpecifier.Size()
	}
	if m.DownstreamProtocol != 0 {
		n += 1 + sovXProxy(uint64(m.DownstreamProtocol))
	}
	if m.UpstreamProtocol != 0 {
		n += 1 + sovXProxy(uint64(m.UpstreamProtocol))
	}
	if len(m.StreamFilters) > 0 {
		for _, e := range m.StreamFilters {
			l = e.Size()
			n += 1 + l + sovXProxy(uint64(l))
		}
	}
	if len(m.MetasToAddToHeader) > 0 {
		for _, s := range m.MetasToAddToHeader {
			l = len(s)
			n += 1 + l + sovXProxy(uint64(l))
		}
	}
	if m.Tracing != nil {
		l = m.Tracing.Size()
		n += 1 + l + sovXProxy(uint64(l))
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovXProxy(uint64(l))
	}
	if m.IdleTimeout != nil {
		l = types.SizeOfStdDuration(*m.IdleTimeout)
		n += 1 + l + sovXProxy(uint64(l))
	}
	if m.DrainTimeout != nil {
		l = types.SizeOfStdDuration(*m.DrainTimeout)
		n += 1 + l + sovXProxy(uint64(l))
	}
	if len(m.AccessLog) > 0 {
		for _, e := range m.AccessLog {
			l = e.Size()
			n += 1 + l + sovXProxy(uint64(l))
		}
	}
	return n
}

func (m *XProxy_Rds) Size() (n int) {
	var l int
	_ = l
	if m.Rds != nil {
		l = m.Rds.Size()
		n += 1 + l + sovXProxy(uint64(l))
	}
	return n
}
func (m *XProxy_RouteConfig) Size() (n int) {
	var l int
	_ = l
	if m.RouteConfig != nil {
		l = m.RouteConfig.Size()
		n += 1 + l + sovXProxy(uint64(l))
	}
	return n
}
func (m *XProxy_Tracing) Size() (n int) {
	var l int
	_ = l
	if m.OperationName != 0 {
		n += 1 + sovXProxy(uint64(m.OperationName))
	}
	if len(m.RequestMetasForTags) > 0 {
		for _, s := range m.RequestMetasForTags {
			l = len(s)
			n += 1 + l + sovXProxy(uint64(l))
		}
	}
	if m.ClientSampling != nil {
		l = m.ClientSampling.Size()
		n += 1 + l + sovXProxy(uint64(l))
	}
	if m.RandomSampling != nil {
		l = m.RandomSampling.Size()
		n += 1 + l + sovXProxy(uint64(l))
	}
	if m.OverallSampling != nil {
		l = m.OverallSampling.Size()
		n += 1 + l + sovXProxy(uint64(l))
	}
	return n
}

func (m *Rds) Size() (n int) {
	var l int
	_ = l
	l = m.ConfigSource.Size()
	n += 1 + l + sovXProxy(uint64(l))
	l = len(m.RouteConfigName)
	if l > 0 {
		n += 1 + l + sovXProxy(uint64(l))
	}
	return n
}

func (m *StreamFilter) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovXProxy(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovXProxy(uint64(l))
	}
	return n
}

func sovXProxy(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozXProxy(x uint64) (n int) {
	return sovXProxy(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *XProxy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: XProxy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: XProxy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XProtocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXProxy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XProtocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXProxy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Rds{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RouteSpecifier = &XProxy_Rds{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &envoy_api_v21.RouteConfiguration{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RouteSpecifier = &XProxy_RouteConfig{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownstreamProtocol", wireType)
			}
			m.DownstreamProtocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownstreamProtocol |= (XProxy_Protocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamProtocol", wireType)
			}
			m.UpstreamProtocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpstreamProtocol |= (XProxy_Protocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamFilters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamFilters = append(m.StreamFilters, &StreamFilter{})
			if err := m.StreamFilters[len(m.StreamFilters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetasToAddToHeader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXProxy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetasToAddToHeader = append(m.MetasToAddToHeader, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tracing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tracing == nil {
				m.Tracing = &XProxy_Tracing{}
			}
			if err := m.Tracing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXProxy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdleTimeout == nil {
				m.IdleTimeout = new(time.Duration)
			}
			if err := types.StdDurationUnmarshal(m.IdleTimeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrainTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DrainTimeout == nil {
				m.DrainTimeout = new(time.Duration)
			}
			if err := types.StdDurationUnmarshal(m.DrainTimeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessLog = append(m.AccessLog, &envoy_config_filter_accesslog_v2.AccessLog{})
			if err := m.AccessLog[len(m.AccessLog)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *XProxy_Tracing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tracing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tracing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationName", wireType)
			}
			m.OperationName = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationName |= (XProxy_Tracing_OperationName(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestMetasForTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXProxy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestMetasForTags = append(m.RequestMetasForTags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSampling", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientSampling == nil {
				m.ClientSampling = &envoy_type1.Percent{}
			}
			if err := m.ClientSampling.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomSampling", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RandomSampling == nil {
				m.RandomSampling = &envoy_type1.Percent{}
			}
			if err := m.RandomSampling.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverallSampling", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OverallSampling == nil {
				m.OverallSampling = &envoy_type1.Percent{}
			}
			if err := m.OverallSampling.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ConfigSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteConfigName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXProxy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteConfigName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXProxy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &google_protobuf.Struct{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipXProxy(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowXProxy
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowXProxy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowXProxy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthXProxy
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowXProxy
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipXProxy(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthXProxy = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowXProxy   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("x_proxy.proto", fileDescriptorXProxy) }

var fileDescriptorXProxy = []byte{
	// 905 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xcb, 0x8e, 0xe3, 0x44,
	0x14, 0x8d, 0xf3, 0xea, 0xc9, 0x75, 0x92, 0xce, 0x54, 0xa3, 0x1e, 0xd3, 0x82, 0x74, 0x14, 0x09,
	0x14, 0x81, 0x64, 0x23, 0x0f, 0x8f, 0x0d, 0x02, 0x4d, 0xe8, 0x1e, 0x1a, 0x04, 0x43, 0xe4, 0x64,
	0x31, 0x02, 0x09, 0xab, 0xc6, 0xae, 0x18, 0x0b, 0xc7, 0x65, 0xaa, 0x2a, 0xe9, 0xee, 0x2d, 0x2b,
	0x84, 0x58, 0xb1, 0x62, 0x3f, 0x3f, 0x81, 0x58, 0xcd, 0x72, 0x96, 0x7c, 0x01, 0xa0, 0xde, 0xcd,
	0x5f, 0xa0, 0x7a, 0x38, 0x8f, 0x1e, 0x40, 0x0d, 0x62, 0xe5, 0xaa, 0x3a, 0xe7, 0xdc, 0xeb, 0xba,
	0x75, 0xeb, 0x14, 0x74, 0x2e, 0xc2, 0x82, 0xd1, 0x8b, 0x4b, 0xb7, 0x60, 0x54, 0x50, 0xf4, 0x2a,
	0xc9, 0x57, 0xf4, 0xd2, 0x8d, 0x68, 0x3e, 0x4f, 0x13, 0x77, 0x9e, 0x66, 0x82, 0x30, 0x37, 0x27,
	0xe2, 0x9c, 0xb2, 0xaf, 0xdd, 0x92, 0xba, 0xf2, 0x8f, 0x5e, 0x51, 0x3c, 0x0f, 0x17, 0xa9, 0xb7,
	0xf2, 0xbd, 0x88, 0x32, 0xe2, 0x69, 0x4d, 0xc8, 0xe9, 0x92, 0x45, 0x44, 0x87, 0x3b, 0x3a, 0xdc,
	0xa1, 0xb1, 0x98, 0x9b, 0xf5, 0x37, 0xf4, 0xba, 0x96, 0x78, 0x3a, 0x8d, 0x87, 0xa3, 0x88, 0x70,
	0x9e, 0xd1, 0x44, 0x72, 0xd7, 0x13, 0xa3, 0x70, 0xb4, 0x42, 0x5c, 0x16, 0xc4, 0x2b, 0x08, 0x8b,
	0x48, 0x2e, 0x0c, 0xd2, 0x4f, 0x28, 0x4d, 0x32, 0xe2, 0xa9, 0xd9, 0xa3, 0xe5, 0xdc, 0x8b, 0x97,
	0x0c, 0x8b, 0x94, 0xe6, 0x06, 0x7f, 0xe9, 0x3a, 0xce, 0x05, 0x5b, 0x46, 0xa5, 0xfa, 0xce, 0x0a,
	0x67, 0x69, 0x8c, 0x05, 0xf1, 0xca, 0x81, 0x01, 0x5e, 0x48, 0x68, 0x42, 0xd5, 0xd0, 0x93, 0x23,
	0xbd, 0x3a, 0xfc, 0xc1, 0x86, 0xe6, 0xc3, 0x89, 0xac, 0x02, 0x1a, 0x01, 0xa8, 0x82, 0x08, 0x1a,
	0xd1, 0xcc, 0xb1, 0x06, 0xd6, 0xa8, 0x35, 0x6e, 0xfd, 0xf2, 0xec, 0x49, 0xad, 0xce, 0xaa, 0x03,
	0x2b, 0x68, 0x5d, 0x4c, 0x0c, 0x86, 0x5e, 0x03, 0x9b, 0x0b, 0x2c, 0xc2, 0x82, 0x91, 0x79, 0x7a,
	0xe1, 0x54, 0xaf, 0x53, 0x41, 0xa2, 0x13, 0x05, 0xa2, 0xf7, 0xa1, 0xc6, 0x62, 0xee, 0xd4, 0x06,
	0xd6, 0xc8, 0xf6, 0x5f, 0x77, 0x6f, 0x76, 0x1c, 0x6e, 0x10, 0xf3, 0xb3, 0x4a, 0x20, 0x95, 0xe8,
	0x14, 0xda, 0x8c, 0x2e, 0x05, 0x09, 0xb5, 0xc8, 0xa9, 0xab, 0x48, 0x03, 0x13, 0x09, 0x17, 0xa9,
	0xe2, 0x4b, 0xc6, 0x07, 0x8a, 0x60, 0x8a, 0x75, 0x56, 0x09, 0x6c, 0xb6, 0x59, 0x45, 0x02, 0x0e,
	0x62, 0x7a, 0x9e, 0x73, 0xc1, 0x08, 0x5e, 0x6c, 0xb6, 0xd9, 0x18, 0x58, 0xa3, 0xae, 0xff, 0xce,
	0x4d, 0xff, 0x4b, 0x97, 0xca, 0x2d, 0x2b, 0x31, 0x06, 0xb9, 0xe9, 0xc6, 0xb7, 0x56, 0xb5, 0x67,
	0x05, 0x68, 0x13, 0x7f, 0x5d, 0xa9, 0x02, 0x6e, 0x2f, 0x8b, 0xeb, 0x39, 0x9b, 0xff, 0x5f, 0xce,
	0x5e, 0x19, 0x7d, 0x9d, 0xf1, 0x0b, 0xe8, 0x9a, 0x7c, 0x3a, 0x22, 0x77, 0xf6, 0x06, 0xb5, 0x91,
	0xed, 0xbf, 0x79, 0xd3, 0x74, 0x53, 0xa5, 0xbe, 0xaf, 0xf0, 0xa0, 0xc3, 0xb7, 0x66, 0x1c, 0xf9,
	0x70, 0xb8, 0x20, 0x02, 0xf3, 0x50, 0xd0, 0x10, 0xc7, 0xb1, 0xfc, 0x7c, 0x45, 0x70, 0x4c, 0x98,
	0x73, 0x6b, 0x50, 0x1b, 0xb5, 0x02, 0xa4, 0xd0, 0x19, 0xbd, 0x17, 0xc7, 0x33, 0x7a, 0xa6, 0x10,
	0x34, 0x81, 0x3d, 0xc1, 0x70, 0x94, 0xe6, 0x89, 0xd3, 0x52, 0x47, 0xf7, 0xf6, 0xbf, 0xdc, 0xf8,
	0x4c, 0xab, 0x83, 0x32, 0x0c, 0x3a, 0x06, 0x9b, 0x13, 0xb6, 0x22, 0x2c, 0xcc, 0xf1, 0x82, 0x38,
	0x20, 0xdb, 0x2f, 0x00, 0xbd, 0xf4, 0x00, 0x2f, 0x08, 0x1a, 0x43, 0x3b, 0x8d, 0x33, 0x12, 0x8a,
	0x74, 0x41, 0xe8, 0x52, 0x38, 0xb6, 0xca, 0xfb, 0xa2, 0xab, 0x2f, 0x8e, 0x5b, 0x5e, 0x1c, 0xf7,
	0xc4, 0xf4, 0xca, 0xb8, 0xfe, 0xd3, 0xef, 0xc7, 0x56, 0x60, 0x4b, 0xd1, 0x4c, 0x6b, 0xd0, 0x09,
	0x74, 0x62, 0x86, 0xd3, 0x7c, 0x1d, 0xa4, 0x7d, 0xb3, 0x20, 0x6d, 0xa5, 0x2a, 0xa3, 0x7c, 0x0c,
	0xa0, 0x2f, 0x7e, 0x98, 0xd1, 0xc4, 0xe9, 0xa8, 0x93, 0xf8, 0xeb, 0x4b, 0xb0, 0xf1, 0x87, 0x95,
	0xef, 0xde, 0x53, 0x93, 0x4f, 0x68, 0x12, 0xb4, 0x70, 0x39, 0x3c, 0x7a, 0x5c, 0x83, 0x3d, 0x53,
	0x0b, 0x74, 0x0e, 0x5d, 0x5a, 0x10, 0x9d, 0x58, 0x57, 0xc1, 0x52, 0x4d, 0x75, 0xf2, 0xdf, 0x6a,
	0xeb, 0x7e, 0x56, 0x06, 0x93, 0xf5, 0xdb, 0xe9, 0xb0, 0x0e, 0xdd, 0x86, 0xd0, 0x5d, 0x38, 0x64,
	0xe4, 0x9b, 0x25, 0xe1, 0x22, 0xd4, 0x9d, 0x30, 0xa7, 0x2c, 0x14, 0x38, 0xe1, 0x4e, 0x55, 0x75,
	0xc0, 0x81, 0x41, 0x3f, 0x95, 0xe0, 0x7d, 0xca, 0x66, 0x38, 0xe1, 0xe8, 0x5d, 0xd8, 0x8f, 0xb2,
	0x94, 0xe4, 0x22, 0xe4, 0x78, 0x51, 0x64, 0xb2, 0x15, 0xb4, 0x1f, 0x1c, 0x98, 0xdf, 0x95, 0x2e,
	0xe8, 0x4e, 0xb4, 0x0b, 0x06, 0x5d, 0xcd, 0x9d, 0x1a, 0xaa, 0x54, 0x33, 0x9c, 0xc7, 0x74, 0xb1,
	0x51, 0xd7, 0xff, 0x41, 0xad, 0xb9, 0x6b, 0xf5, 0x7b, 0xd0, 0xa3, 0x2b, 0xc2, 0x70, 0x96, 0x6d,
	0xe4, 0x8d, 0xbf, 0x97, 0xef, 0x1b, 0x72, 0xa9, 0x1f, 0xba, 0xd0, 0xd9, 0x29, 0x0e, 0xb2, 0x61,
	0xef, 0xa3, 0x07, 0x1f, 0x06, 0xa7, 0xd3, 0x69, 0xaf, 0x82, 0x00, 0x9a, 0xa7, 0x7a, 0x6c, 0x1d,
	0xd5, 0xbf, 0x7b, 0xdc, 0xaf, 0x0c, 0x87, 0x70, 0x6b, 0x7d, 0x17, 0x1b, 0x60, 0x3d, 0xec, 0x55,
	0x50, 0x0b, 0x1a, 0x67, 0xb3, 0xd9, 0xc4, 0x2f, 0x39, 0x63, 0x07, 0xf6, 0xb5, 0xa5, 0xf1, 0x82,
	0x44, 0xe9, 0x3c, 0x25, 0x0c, 0x35, 0x7e, 0x7e, 0xf6, 0xa4, 0x66, 0x0d, 0x7f, 0xb4, 0xa0, 0x16,
	0xc4, 0x1c, 0xcd, 0xa0, 0xb3, 0xf3, 0xfc, 0xa8, 0xe3, 0xb5, 0xfd, 0xe3, 0x5d, 0xd7, 0x93, 0xcf,
	0x94, 0xab, 0xfd, 0x6d, 0xaa, 0x68, 0xe3, 0xee, 0xd3, 0xdf, 0x8e, 0x2b, 0xea, 0xf4, 0xbe, 0x57,
	0xa7, 0xd7, 0x8e, 0xb6, 0x50, 0xf4, 0x16, 0xdc, 0xde, 0xb6, 0x52, 0xdd, 0x38, 0xcf, 0xb9, 0xf7,
	0xfe, 0x96, 0x6d, 0xca, 0x1d, 0x0f, 0xbf, 0x84, 0xf6, 0xb6, 0x29, 0xa0, 0x97, 0xa1, 0xbe, 0x6e,
	0xb9, 0x1d, 0xa5, 0x5a, 0x46, 0x1e, 0x34, 0x8d, 0x55, 0x57, 0xd5, 0x4f, 0xdf, 0x79, 0xee, 0xca,
	0x4c, 0xd5, 0x83, 0x15, 0x18, 0xda, 0xb8, 0xf7, 0xf4, 0xaa, 0x6f, 0xfd, 0x7a, 0xd5, 0xb7, 0xfe,
	0xb8, 0xea, 0x5b, 0x9f, 0x57, 0x57, 0xfe, 0xa3, 0xa6, 0xa2, 0xde, 0xfd, 0x33, 0x00, 0x00, 0xff,
	0xff, 0x9c, 0x4b, 0xf7, 0x2d, 0xcd, 0x07, 0x00, 0x00,
}
