// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"istio.io/istio/pilot/pkg/model"
)

type ServiceDiscovery struct {
	ServicesStub        func() ([]*model.Service, error)
	servicesMutex       sync.RWMutex
	servicesArgsForCall []struct{}
	servicesReturns     struct {
		result1 []*model.Service
		result2 error
	}
	servicesReturnsOnCall map[int]struct {
		result1 []*model.Service
		result2 error
	}
	GetServiceStub        func(hostname model.Hostname) (*model.Service, error)
	getServiceMutex       sync.RWMutex
	getServiceArgsForCall []struct {
		hostname model.Hostname
	}
	getServiceReturns struct {
		result1 *model.Service
		result2 error
	}
	getServiceReturnsOnCall map[int]struct {
		result1 *model.Service
		result2 error
	}
	GetServiceAttributesStub        func(hostname model.Hostname) (*model.ServiceAttributes, error)
	getServiceAttributesMutex       sync.RWMutex
	getServiceAttributesArgsForCall []struct {
		hostname model.Hostname
	}
	getServiceAttributesReturns struct {
		result1 *model.ServiceAttributes
		result2 error
	}
	getServiceAttributesReturnsOnCall map[int]struct {
		result1 *model.ServiceAttributes
		result2 error
	}
	InstancesStub        func(hostname model.Hostname, ports []string, labels model.LabelsCollection) ([]*model.ServiceInstance, error)
	instancesMutex       sync.RWMutex
	instancesArgsForCall []struct {
		hostname model.Hostname
		ports    []string
		labels   model.LabelsCollection
	}
	instancesReturns struct {
		result1 []*model.ServiceInstance
		result2 error
	}
	instancesReturnsOnCall map[int]struct {
		result1 []*model.ServiceInstance
		result2 error
	}
	InstancesByPortStub        func(hostname model.Hostname, servicePort int, labels model.LabelsCollection) ([]*model.ServiceInstance, error)
	instancesByPortMutex       sync.RWMutex
	instancesByPortArgsForCall []struct {
		hostname    model.Hostname
		servicePort int
		labels      model.LabelsCollection
	}
	instancesByPortReturns struct {
		result1 []*model.ServiceInstance
		result2 error
	}
	instancesByPortReturnsOnCall map[int]struct {
		result1 []*model.ServiceInstance
		result2 error
	}
	GetProxyServiceInstancesStub        func(*model.Proxy) ([]*model.ServiceInstance, error)
	getProxyServiceInstancesMutex       sync.RWMutex
	getProxyServiceInstancesArgsForCall []struct {
		arg1 *model.Proxy
	}
	getProxyServiceInstancesReturns struct {
		result1 []*model.ServiceInstance
		result2 error
	}
	getProxyServiceInstancesReturnsOnCall map[int]struct {
		result1 []*model.ServiceInstance
		result2 error
	}
	ManagementPortsStub        func(addr string) model.PortList
	managementPortsMutex       sync.RWMutex
	managementPortsArgsForCall []struct {
		addr string
	}
	managementPortsReturns struct {
		result1 model.PortList
	}
	managementPortsReturnsOnCall map[int]struct {
		result1 model.PortList
	}
	WorkloadHealthCheckInfoStub        func(addr string) model.ProbeList
	workloadHealthCheckInfoMutex       sync.RWMutex
	workloadHealthCheckInfoArgsForCall []struct {
		addr string
	}
	workloadHealthCheckInfoReturns struct {
		result1 model.ProbeList
	}
	workloadHealthCheckInfoReturnsOnCall map[int]struct {
		result1 model.ProbeList
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *ServiceDiscovery) Services() ([]*model.Service, error) {
	fake.servicesMutex.Lock()
	ret, specificReturn := fake.servicesReturnsOnCall[len(fake.servicesArgsForCall)]
	fake.servicesArgsForCall = append(fake.servicesArgsForCall, struct{}{})
	fake.recordInvocation("Services", []interface{}{})
	fake.servicesMutex.Unlock()
	if fake.ServicesStub != nil {
		return fake.ServicesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.servicesReturns.result1, fake.servicesReturns.result2
}

func (fake *ServiceDiscovery) ServicesCallCount() int {
	fake.servicesMutex.RLock()
	defer fake.servicesMutex.RUnlock()
	return len(fake.servicesArgsForCall)
}

func (fake *ServiceDiscovery) ServicesReturns(result1 []*model.Service, result2 error) {
	fake.ServicesStub = nil
	fake.servicesReturns = struct {
		result1 []*model.Service
		result2 error
	}{result1, result2}
}

func (fake *ServiceDiscovery) ServicesReturnsOnCall(i int, result1 []*model.Service, result2 error) {
	fake.ServicesStub = nil
	if fake.servicesReturnsOnCall == nil {
		fake.servicesReturnsOnCall = make(map[int]struct {
			result1 []*model.Service
			result2 error
		})
	}
	fake.servicesReturnsOnCall[i] = struct {
		result1 []*model.Service
		result2 error
	}{result1, result2}
}

func (fake *ServiceDiscovery) GetService(hostname model.Hostname) (*model.Service, error) {
	fake.getServiceMutex.Lock()
	ret, specificReturn := fake.getServiceReturnsOnCall[len(fake.getServiceArgsForCall)]
	fake.getServiceArgsForCall = append(fake.getServiceArgsForCall, struct {
		hostname model.Hostname
	}{hostname})
	fake.recordInvocation("GetService", []interface{}{hostname})
	fake.getServiceMutex.Unlock()
	if fake.GetServiceStub != nil {
		return fake.GetServiceStub(hostname)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getServiceReturns.result1, fake.getServiceReturns.result2
}

func (fake *ServiceDiscovery) GetServiceCallCount() int {
	fake.getServiceMutex.RLock()
	defer fake.getServiceMutex.RUnlock()
	return len(fake.getServiceArgsForCall)
}

func (fake *ServiceDiscovery) GetServiceArgsForCall(i int) model.Hostname {
	fake.getServiceMutex.RLock()
	defer fake.getServiceMutex.RUnlock()
	return fake.getServiceArgsForCall[i].hostname
}

func (fake *ServiceDiscovery) GetServiceReturns(result1 *model.Service, result2 error) {
	fake.GetServiceStub = nil
	fake.getServiceReturns = struct {
		result1 *model.Service
		result2 error
	}{result1, result2}
}

func (fake *ServiceDiscovery) GetServiceReturnsOnCall(i int, result1 *model.Service, result2 error) {
	fake.GetServiceStub = nil
	if fake.getServiceReturnsOnCall == nil {
		fake.getServiceReturnsOnCall = make(map[int]struct {
			result1 *model.Service
			result2 error
		})
	}
	fake.getServiceReturnsOnCall[i] = struct {
		result1 *model.Service
		result2 error
	}{result1, result2}
}

func (fake *ServiceDiscovery) GetServiceAttributes(hostname model.Hostname) (*model.ServiceAttributes, error) {
	fake.getServiceAttributesMutex.Lock()
	ret, specificReturn := fake.getServiceAttributesReturnsOnCall[len(fake.getServiceAttributesArgsForCall)]
	fake.getServiceAttributesArgsForCall = append(fake.getServiceAttributesArgsForCall, struct {
		hostname model.Hostname
	}{hostname})
	fake.recordInvocation("GetServiceAttributes", []interface{}{hostname})
	fake.getServiceAttributesMutex.Unlock()
	if fake.GetServiceAttributesStub != nil {
		return fake.GetServiceAttributesStub(hostname)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getServiceAttributesReturns.result1, fake.getServiceAttributesReturns.result2
}

func (fake *ServiceDiscovery) GetServiceAttributesCallCount() int {
	fake.getServiceAttributesMutex.RLock()
	defer fake.getServiceAttributesMutex.RUnlock()
	return len(fake.getServiceAttributesArgsForCall)
}

func (fake *ServiceDiscovery) GetServiceAttributesArgsForCall(i int) model.Hostname {
	fake.getServiceAttributesMutex.RLock()
	defer fake.getServiceAttributesMutex.RUnlock()
	return fake.getServiceAttributesArgsForCall[i].hostname
}

func (fake *ServiceDiscovery) GetServiceAttributesReturns(result1 *model.ServiceAttributes, result2 error) {
	fake.GetServiceAttributesStub = nil
	fake.getServiceAttributesReturns = struct {
		result1 *model.ServiceAttributes
		result2 error
	}{result1, result2}
}

func (fake *ServiceDiscovery) GetServiceAttributesReturnsOnCall(i int, result1 *model.ServiceAttributes, result2 error) {
	fake.GetServiceAttributesStub = nil
	if fake.getServiceAttributesReturnsOnCall == nil {
		fake.getServiceAttributesReturnsOnCall = make(map[int]struct {
			result1 *model.ServiceAttributes
			result2 error
		})
	}
	fake.getServiceAttributesReturnsOnCall[i] = struct {
		result1 *model.ServiceAttributes
		result2 error
	}{result1, result2}
}

func (fake *ServiceDiscovery) Instances(hostname model.Hostname, ports []string, labels model.LabelsCollection) ([]*model.ServiceInstance, error) {
	var portsCopy []string
	if ports != nil {
		portsCopy = make([]string, len(ports))
		copy(portsCopy, ports)
	}
	fake.instancesMutex.Lock()
	ret, specificReturn := fake.instancesReturnsOnCall[len(fake.instancesArgsForCall)]
	fake.instancesArgsForCall = append(fake.instancesArgsForCall, struct {
		hostname model.Hostname
		ports    []string
		labels   model.LabelsCollection
	}{hostname, portsCopy, labels})
	fake.recordInvocation("Instances", []interface{}{hostname, portsCopy, labels})
	fake.instancesMutex.Unlock()
	if fake.InstancesStub != nil {
		return fake.InstancesStub(hostname, ports, labels)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.instancesReturns.result1, fake.instancesReturns.result2
}

func (fake *ServiceDiscovery) InstancesCallCount() int {
	fake.instancesMutex.RLock()
	defer fake.instancesMutex.RUnlock()
	return len(fake.instancesArgsForCall)
}

func (fake *ServiceDiscovery) InstancesArgsForCall(i int) (model.Hostname, []string, model.LabelsCollection) {
	fake.instancesMutex.RLock()
	defer fake.instancesMutex.RUnlock()
	return fake.instancesArgsForCall[i].hostname, fake.instancesArgsForCall[i].ports, fake.instancesArgsForCall[i].labels
}

func (fake *ServiceDiscovery) InstancesReturns(result1 []*model.ServiceInstance, result2 error) {
	fake.InstancesStub = nil
	fake.instancesReturns = struct {
		result1 []*model.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *ServiceDiscovery) InstancesReturnsOnCall(i int, result1 []*model.ServiceInstance, result2 error) {
	fake.InstancesStub = nil
	if fake.instancesReturnsOnCall == nil {
		fake.instancesReturnsOnCall = make(map[int]struct {
			result1 []*model.ServiceInstance
			result2 error
		})
	}
	fake.instancesReturnsOnCall[i] = struct {
		result1 []*model.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *ServiceDiscovery) InstancesByPort(hostname model.Hostname, servicePort int, labels model.LabelsCollection) ([]*model.ServiceInstance, error) {
	fake.instancesByPortMutex.Lock()
	ret, specificReturn := fake.instancesByPortReturnsOnCall[len(fake.instancesByPortArgsForCall)]
	fake.instancesByPortArgsForCall = append(fake.instancesByPortArgsForCall, struct {
		hostname    model.Hostname
		servicePort int
		labels      model.LabelsCollection
	}{hostname, servicePort, labels})
	fake.recordInvocation("InstancesByPort", []interface{}{hostname, servicePort, labels})
	fake.instancesByPortMutex.Unlock()
	if fake.InstancesByPortStub != nil {
		return fake.InstancesByPortStub(hostname, servicePort, labels)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.instancesByPortReturns.result1, fake.instancesByPortReturns.result2
}

func (fake *ServiceDiscovery) InstancesByPortCallCount() int {
	fake.instancesByPortMutex.RLock()
	defer fake.instancesByPortMutex.RUnlock()
	return len(fake.instancesByPortArgsForCall)
}

func (fake *ServiceDiscovery) InstancesByPortArgsForCall(i int) (model.Hostname, int, model.LabelsCollection) {
	fake.instancesByPortMutex.RLock()
	defer fake.instancesByPortMutex.RUnlock()
	return fake.instancesByPortArgsForCall[i].hostname, fake.instancesByPortArgsForCall[i].servicePort, fake.instancesByPortArgsForCall[i].labels
}

func (fake *ServiceDiscovery) InstancesByPortReturns(result1 []*model.ServiceInstance, result2 error) {
	fake.InstancesByPortStub = nil
	fake.instancesByPortReturns = struct {
		result1 []*model.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *ServiceDiscovery) InstancesByPortReturnsOnCall(i int, result1 []*model.ServiceInstance, result2 error) {
	fake.InstancesByPortStub = nil
	if fake.instancesByPortReturnsOnCall == nil {
		fake.instancesByPortReturnsOnCall = make(map[int]struct {
			result1 []*model.ServiceInstance
			result2 error
		})
	}
	fake.instancesByPortReturnsOnCall[i] = struct {
		result1 []*model.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *ServiceDiscovery) GetProxyServiceInstances(arg1 *model.Proxy) ([]*model.ServiceInstance, error) {
	fake.getProxyServiceInstancesMutex.Lock()
	ret, specificReturn := fake.getProxyServiceInstancesReturnsOnCall[len(fake.getProxyServiceInstancesArgsForCall)]
	fake.getProxyServiceInstancesArgsForCall = append(fake.getProxyServiceInstancesArgsForCall, struct {
		arg1 *model.Proxy
	}{arg1})
	fake.recordInvocation("GetProxyServiceInstances", []interface{}{arg1})
	fake.getProxyServiceInstancesMutex.Unlock()
	if fake.GetProxyServiceInstancesStub != nil {
		return fake.GetProxyServiceInstancesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getProxyServiceInstancesReturns.result1, fake.getProxyServiceInstancesReturns.result2
}

func (fake *ServiceDiscovery) GetProxyServiceInstancesCallCount() int {
	fake.getProxyServiceInstancesMutex.RLock()
	defer fake.getProxyServiceInstancesMutex.RUnlock()
	return len(fake.getProxyServiceInstancesArgsForCall)
}

func (fake *ServiceDiscovery) GetProxyServiceInstancesArgsForCall(i int) *model.Proxy {
	fake.getProxyServiceInstancesMutex.RLock()
	defer fake.getProxyServiceInstancesMutex.RUnlock()
	return fake.getProxyServiceInstancesArgsForCall[i].arg1
}

func (fake *ServiceDiscovery) GetProxyServiceInstancesReturns(result1 []*model.ServiceInstance, result2 error) {
	fake.GetProxyServiceInstancesStub = nil
	fake.getProxyServiceInstancesReturns = struct {
		result1 []*model.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *ServiceDiscovery) GetProxyServiceInstancesReturnsOnCall(i int, result1 []*model.ServiceInstance, result2 error) {
	fake.GetProxyServiceInstancesStub = nil
	if fake.getProxyServiceInstancesReturnsOnCall == nil {
		fake.getProxyServiceInstancesReturnsOnCall = make(map[int]struct {
			result1 []*model.ServiceInstance
			result2 error
		})
	}
	fake.getProxyServiceInstancesReturnsOnCall[i] = struct {
		result1 []*model.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *ServiceDiscovery) ManagementPorts(addr string) model.PortList {
	fake.managementPortsMutex.Lock()
	ret, specificReturn := fake.managementPortsReturnsOnCall[len(fake.managementPortsArgsForCall)]
	fake.managementPortsArgsForCall = append(fake.managementPortsArgsForCall, struct {
		addr string
	}{addr})
	fake.recordInvocation("ManagementPorts", []interface{}{addr})
	fake.managementPortsMutex.Unlock()
	if fake.ManagementPortsStub != nil {
		return fake.ManagementPortsStub(addr)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.managementPortsReturns.result1
}

func (fake *ServiceDiscovery) ManagementPortsCallCount() int {
	fake.managementPortsMutex.RLock()
	defer fake.managementPortsMutex.RUnlock()
	return len(fake.managementPortsArgsForCall)
}

func (fake *ServiceDiscovery) ManagementPortsArgsForCall(i int) string {
	fake.managementPortsMutex.RLock()
	defer fake.managementPortsMutex.RUnlock()
	return fake.managementPortsArgsForCall[i].addr
}

func (fake *ServiceDiscovery) ManagementPortsReturns(result1 model.PortList) {
	fake.ManagementPortsStub = nil
	fake.managementPortsReturns = struct {
		result1 model.PortList
	}{result1}
}

func (fake *ServiceDiscovery) ManagementPortsReturnsOnCall(i int, result1 model.PortList) {
	fake.ManagementPortsStub = nil
	if fake.managementPortsReturnsOnCall == nil {
		fake.managementPortsReturnsOnCall = make(map[int]struct {
			result1 model.PortList
		})
	}
	fake.managementPortsReturnsOnCall[i] = struct {
		result1 model.PortList
	}{result1}
}

func (fake *ServiceDiscovery) WorkloadHealthCheckInfo(addr string) model.ProbeList {
	fake.workloadHealthCheckInfoMutex.Lock()
	ret, specificReturn := fake.workloadHealthCheckInfoReturnsOnCall[len(fake.workloadHealthCheckInfoArgsForCall)]
	fake.workloadHealthCheckInfoArgsForCall = append(fake.workloadHealthCheckInfoArgsForCall, struct {
		addr string
	}{addr})
	fake.recordInvocation("WorkloadHealthCheckInfo", []interface{}{addr})
	fake.workloadHealthCheckInfoMutex.Unlock()
	if fake.WorkloadHealthCheckInfoStub != nil {
		return fake.WorkloadHealthCheckInfoStub(addr)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.workloadHealthCheckInfoReturns.result1
}

func (fake *ServiceDiscovery) WorkloadHealthCheckInfoCallCount() int {
	fake.workloadHealthCheckInfoMutex.RLock()
	defer fake.workloadHealthCheckInfoMutex.RUnlock()
	return len(fake.workloadHealthCheckInfoArgsForCall)
}

func (fake *ServiceDiscovery) WorkloadHealthCheckInfoArgsForCall(i int) string {
	fake.workloadHealthCheckInfoMutex.RLock()
	defer fake.workloadHealthCheckInfoMutex.RUnlock()
	return fake.workloadHealthCheckInfoArgsForCall[i].addr
}

func (fake *ServiceDiscovery) WorkloadHealthCheckInfoReturns(result1 model.ProbeList) {
	fake.WorkloadHealthCheckInfoStub = nil
	fake.workloadHealthCheckInfoReturns = struct {
		result1 model.ProbeList
	}{result1}
}

func (fake *ServiceDiscovery) WorkloadHealthCheckInfoReturnsOnCall(i int, result1 model.ProbeList) {
	fake.WorkloadHealthCheckInfoStub = nil
	if fake.workloadHealthCheckInfoReturnsOnCall == nil {
		fake.workloadHealthCheckInfoReturnsOnCall = make(map[int]struct {
			result1 model.ProbeList
		})
	}
	fake.workloadHealthCheckInfoReturnsOnCall[i] = struct {
		result1 model.ProbeList
	}{result1}
}

func (fake *ServiceDiscovery) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.servicesMutex.RLock()
	defer fake.servicesMutex.RUnlock()
	fake.getServiceMutex.RLock()
	defer fake.getServiceMutex.RUnlock()
	fake.getServiceAttributesMutex.RLock()
	defer fake.getServiceAttributesMutex.RUnlock()
	fake.instancesMutex.RLock()
	defer fake.instancesMutex.RUnlock()
	fake.instancesByPortMutex.RLock()
	defer fake.instancesByPortMutex.RUnlock()
	fake.getProxyServiceInstancesMutex.RLock()
	defer fake.getProxyServiceInstancesMutex.RUnlock()
	fake.managementPortsMutex.RLock()
	defer fake.managementPortsMutex.RUnlock()
	fake.workloadHealthCheckInfoMutex.RLock()
	defer fake.workloadHealthCheckInfoMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *ServiceDiscovery) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ model.ServiceDiscovery = new(ServiceDiscovery)
