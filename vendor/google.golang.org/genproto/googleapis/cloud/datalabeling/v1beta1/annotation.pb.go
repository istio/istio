// Code generated by protoc-gen-go. DO NOT EDIT.
// source: google/cloud/datalabeling/v1beta1/annotation.proto

package datalabeling // import "google.golang.org/genproto/googleapis/cloud/datalabeling/v1beta1"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import duration "github.com/golang/protobuf/ptypes/duration"
import _ "github.com/golang/protobuf/ptypes/struct"
import _ "github.com/golang/protobuf/ptypes/timestamp"
import _ "google.golang.org/genproto/googleapis/api/annotations"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Specifies where is the answer from.
type AnnotationSource int32

const (
	AnnotationSource_ANNOTATION_SOURCE_UNSPECIFIED AnnotationSource = 0
	// Answer is provided by a human contributor.
	AnnotationSource_OPERATOR AnnotationSource = 3
)

var AnnotationSource_name = map[int32]string{
	0: "ANNOTATION_SOURCE_UNSPECIFIED",
	3: "OPERATOR",
}
var AnnotationSource_value = map[string]int32{
	"ANNOTATION_SOURCE_UNSPECIFIED": 0,
	"OPERATOR":                      3,
}

func (x AnnotationSource) String() string {
	return proto.EnumName(AnnotationSource_name, int32(x))
}
func (AnnotationSource) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_annotation_1df8bdb649b04239, []int{0}
}

type AnnotationSentiment int32

const (
	AnnotationSentiment_ANNOTATION_SENTIMENT_UNSPECIFIED AnnotationSentiment = 0
	// This annotation describes negatively about the data.
	AnnotationSentiment_NEGATIVE AnnotationSentiment = 1
	// This label describes positively about the data.
	AnnotationSentiment_POSITIVE AnnotationSentiment = 2
)

var AnnotationSentiment_name = map[int32]string{
	0: "ANNOTATION_SENTIMENT_UNSPECIFIED",
	1: "NEGATIVE",
	2: "POSITIVE",
}
var AnnotationSentiment_value = map[string]int32{
	"ANNOTATION_SENTIMENT_UNSPECIFIED": 0,
	"NEGATIVE":                         1,
	"POSITIVE":                         2,
}

func (x AnnotationSentiment) String() string {
	return proto.EnumName(AnnotationSentiment_name, int32(x))
}
func (AnnotationSentiment) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_annotation_1df8bdb649b04239, []int{1}
}

type AnnotationType int32

const (
	AnnotationType_ANNOTATION_TYPE_UNSPECIFIED AnnotationType = 0
	// Classification annotations in an image.
	AnnotationType_IMAGE_CLASSIFICATION_ANNOTATION AnnotationType = 1
	// Bounding box annotations in an image.
	AnnotationType_IMAGE_BOUNDING_BOX_ANNOTATION AnnotationType = 2
	// Oriented bounding box. The box does not have to be parallel to horizontal
	// line.
	AnnotationType_IMAGE_ORIENTED_BOUNDING_BOX_ANNOTATION AnnotationType = 13
	// Bounding poly annotations in an image.
	AnnotationType_IMAGE_BOUNDING_POLY_ANNOTATION AnnotationType = 10
	// Polyline annotations in an image.
	AnnotationType_IMAGE_POLYLINE_ANNOTATION AnnotationType = 11
	// Segmentation annotations in an image.
	AnnotationType_IMAGE_SEGMENTATION_ANNOTATION AnnotationType = 12
	// Classification annotations in video shots.
	AnnotationType_VIDEO_SHOTS_CLASSIFICATION_ANNOTATION AnnotationType = 3
	// Video object tracking annotation.
	AnnotationType_VIDEO_OBJECT_TRACKING_ANNOTATION AnnotationType = 4
	// Video object detection annotation.
	AnnotationType_VIDEO_OBJECT_DETECTION_ANNOTATION AnnotationType = 5
	// Video event annotation.
	AnnotationType_VIDEO_EVENT_ANNOTATION AnnotationType = 6
	// Speech to text annotation.
	AnnotationType_AUDIO_TRANSCRIPTION_ANNOTATION AnnotationType = 7
	// Classification for text.
	AnnotationType_TEXT_CLASSIFICATION_ANNOTATION AnnotationType = 8
	// Entity extraction for text.
	AnnotationType_TEXT_ENTITY_EXTRACTION_ANNOTATION AnnotationType = 9
)

var AnnotationType_name = map[int32]string{
	0:  "ANNOTATION_TYPE_UNSPECIFIED",
	1:  "IMAGE_CLASSIFICATION_ANNOTATION",
	2:  "IMAGE_BOUNDING_BOX_ANNOTATION",
	13: "IMAGE_ORIENTED_BOUNDING_BOX_ANNOTATION",
	10: "IMAGE_BOUNDING_POLY_ANNOTATION",
	11: "IMAGE_POLYLINE_ANNOTATION",
	12: "IMAGE_SEGMENTATION_ANNOTATION",
	3:  "VIDEO_SHOTS_CLASSIFICATION_ANNOTATION",
	4:  "VIDEO_OBJECT_TRACKING_ANNOTATION",
	5:  "VIDEO_OBJECT_DETECTION_ANNOTATION",
	6:  "VIDEO_EVENT_ANNOTATION",
	7:  "AUDIO_TRANSCRIPTION_ANNOTATION",
	8:  "TEXT_CLASSIFICATION_ANNOTATION",
	9:  "TEXT_ENTITY_EXTRACTION_ANNOTATION",
}
var AnnotationType_value = map[string]int32{
	"ANNOTATION_TYPE_UNSPECIFIED":            0,
	"IMAGE_CLASSIFICATION_ANNOTATION":        1,
	"IMAGE_BOUNDING_BOX_ANNOTATION":          2,
	"IMAGE_ORIENTED_BOUNDING_BOX_ANNOTATION": 13,
	"IMAGE_BOUNDING_POLY_ANNOTATION":         10,
	"IMAGE_POLYLINE_ANNOTATION":              11,
	"IMAGE_SEGMENTATION_ANNOTATION":          12,
	"VIDEO_SHOTS_CLASSIFICATION_ANNOTATION":  3,
	"VIDEO_OBJECT_TRACKING_ANNOTATION":       4,
	"VIDEO_OBJECT_DETECTION_ANNOTATION":      5,
	"VIDEO_EVENT_ANNOTATION":                 6,
	"AUDIO_TRANSCRIPTION_ANNOTATION":         7,
	"TEXT_CLASSIFICATION_ANNOTATION":         8,
	"TEXT_ENTITY_EXTRACTION_ANNOTATION":      9,
}

func (x AnnotationType) String() string {
	return proto.EnumName(AnnotationType_name, int32(x))
}
func (AnnotationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_annotation_1df8bdb649b04239, []int{2}
}

// Annotation for Example. Each example may have one or more annotations. For
// example in image classification problem, each image might have one or more
// labels. We call labels binded with this image an Annotation.
type Annotation struct {
	// Output only. Unique name of this annotation, format is:
	//
	// projects/{project_id}/datasets/{dataset_id}/annotatedDatasets/{annotated_dataset}/examples/{example_id}/annotations/{annotation_id}
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Output only. The source of the annotation.
	AnnotationSource AnnotationSource `protobuf:"varint,2,opt,name=annotation_source,json=annotationSource,proto3,enum=google.cloud.datalabeling.v1beta1.AnnotationSource" json:"annotation_source,omitempty"`
	// Output only. This is the actual annotation value, e.g classification,
	// bounding box values are stored here.
	AnnotationValue *AnnotationValue `protobuf:"bytes,3,opt,name=annotation_value,json=annotationValue,proto3" json:"annotation_value,omitempty"`
	// Output only. Annotation metadata, including information like votes
	// for labels.
	AnnotationMetadata *AnnotationMetadata `protobuf:"bytes,4,opt,name=annotation_metadata,json=annotationMetadata,proto3" json:"annotation_metadata,omitempty"`
	// Output only. Sentiment for this annotation.
	AnnotationSentiment  AnnotationSentiment `protobuf:"varint,6,opt,name=annotation_sentiment,json=annotationSentiment,proto3,enum=google.cloud.datalabeling.v1beta1.AnnotationSentiment" json:"annotation_sentiment,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Annotation) Reset()         { *m = Annotation{} }
func (m *Annotation) String() string { return proto.CompactTextString(m) }
func (*Annotation) ProtoMessage()    {}
func (*Annotation) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotation_1df8bdb649b04239, []int{0}
}
func (m *Annotation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Annotation.Unmarshal(m, b)
}
func (m *Annotation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Annotation.Marshal(b, m, deterministic)
}
func (dst *Annotation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Annotation.Merge(dst, src)
}
func (m *Annotation) XXX_Size() int {
	return xxx_messageInfo_Annotation.Size(m)
}
func (m *Annotation) XXX_DiscardUnknown() {
	xxx_messageInfo_Annotation.DiscardUnknown(m)
}

var xxx_messageInfo_Annotation proto.InternalMessageInfo

func (m *Annotation) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Annotation) GetAnnotationSource() AnnotationSource {
	if m != nil {
		return m.AnnotationSource
	}
	return AnnotationSource_ANNOTATION_SOURCE_UNSPECIFIED
}

func (m *Annotation) GetAnnotationValue() *AnnotationValue {
	if m != nil {
		return m.AnnotationValue
	}
	return nil
}

func (m *Annotation) GetAnnotationMetadata() *AnnotationMetadata {
	if m != nil {
		return m.AnnotationMetadata
	}
	return nil
}

func (m *Annotation) GetAnnotationSentiment() AnnotationSentiment {
	if m != nil {
		return m.AnnotationSentiment
	}
	return AnnotationSentiment_ANNOTATION_SENTIMENT_UNSPECIFIED
}

// Annotation value for an example.
type AnnotationValue struct {
	// Types that are valid to be assigned to ValueType:
	//	*AnnotationValue_ImageClassificationAnnotation
	//	*AnnotationValue_ImageBoundingPolyAnnotation
	//	*AnnotationValue_ImagePolylineAnnotation
	//	*AnnotationValue_ImageSegmentationAnnotation
	//	*AnnotationValue_TextClassificationAnnotation
	//	*AnnotationValue_VideoClassificationAnnotation
	//	*AnnotationValue_VideoObjectTrackingAnnotation
	//	*AnnotationValue_VideoEventAnnotation
	//	*AnnotationValue_AudioRecognitionAnnotation
	ValueType            isAnnotationValue_ValueType `protobuf_oneof:"value_type"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *AnnotationValue) Reset()         { *m = AnnotationValue{} }
func (m *AnnotationValue) String() string { return proto.CompactTextString(m) }
func (*AnnotationValue) ProtoMessage()    {}
func (*AnnotationValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotation_1df8bdb649b04239, []int{1}
}
func (m *AnnotationValue) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AnnotationValue.Unmarshal(m, b)
}
func (m *AnnotationValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AnnotationValue.Marshal(b, m, deterministic)
}
func (dst *AnnotationValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnnotationValue.Merge(dst, src)
}
func (m *AnnotationValue) XXX_Size() int {
	return xxx_messageInfo_AnnotationValue.Size(m)
}
func (m *AnnotationValue) XXX_DiscardUnknown() {
	xxx_messageInfo_AnnotationValue.DiscardUnknown(m)
}

var xxx_messageInfo_AnnotationValue proto.InternalMessageInfo

type isAnnotationValue_ValueType interface {
	isAnnotationValue_ValueType()
}

type AnnotationValue_ImageClassificationAnnotation struct {
	ImageClassificationAnnotation *ImageClassificationAnnotation `protobuf:"bytes,1,opt,name=image_classification_annotation,json=imageClassificationAnnotation,proto3,oneof"`
}

type AnnotationValue_ImageBoundingPolyAnnotation struct {
	ImageBoundingPolyAnnotation *ImageBoundingPolyAnnotation `protobuf:"bytes,2,opt,name=image_bounding_poly_annotation,json=imageBoundingPolyAnnotation,proto3,oneof"`
}

type AnnotationValue_ImagePolylineAnnotation struct {
	ImagePolylineAnnotation *ImagePolylineAnnotation `protobuf:"bytes,8,opt,name=image_polyline_annotation,json=imagePolylineAnnotation,proto3,oneof"`
}

type AnnotationValue_ImageSegmentationAnnotation struct {
	ImageSegmentationAnnotation *ImageSegmentationAnnotation `protobuf:"bytes,9,opt,name=image_segmentation_annotation,json=imageSegmentationAnnotation,proto3,oneof"`
}

type AnnotationValue_TextClassificationAnnotation struct {
	TextClassificationAnnotation *TextClassificationAnnotation `protobuf:"bytes,3,opt,name=text_classification_annotation,json=textClassificationAnnotation,proto3,oneof"`
}

type AnnotationValue_VideoClassificationAnnotation struct {
	VideoClassificationAnnotation *VideoClassificationAnnotation `protobuf:"bytes,4,opt,name=video_classification_annotation,json=videoClassificationAnnotation,proto3,oneof"`
}

type AnnotationValue_VideoObjectTrackingAnnotation struct {
	VideoObjectTrackingAnnotation *VideoObjectTrackingAnnotation `protobuf:"bytes,5,opt,name=video_object_tracking_annotation,json=videoObjectTrackingAnnotation,proto3,oneof"`
}

type AnnotationValue_VideoEventAnnotation struct {
	VideoEventAnnotation *VideoEventAnnotation `protobuf:"bytes,6,opt,name=video_event_annotation,json=videoEventAnnotation,proto3,oneof"`
}

type AnnotationValue_AudioRecognitionAnnotation struct {
	AudioRecognitionAnnotation *AudioRecognitionAnnotation `protobuf:"bytes,7,opt,name=audio_recognition_annotation,json=audioRecognitionAnnotation,proto3,oneof"`
}

func (*AnnotationValue_ImageClassificationAnnotation) isAnnotationValue_ValueType() {}

func (*AnnotationValue_ImageBoundingPolyAnnotation) isAnnotationValue_ValueType() {}

func (*AnnotationValue_ImagePolylineAnnotation) isAnnotationValue_ValueType() {}

func (*AnnotationValue_ImageSegmentationAnnotation) isAnnotationValue_ValueType() {}

func (*AnnotationValue_TextClassificationAnnotation) isAnnotationValue_ValueType() {}

func (*AnnotationValue_VideoClassificationAnnotation) isAnnotationValue_ValueType() {}

func (*AnnotationValue_VideoObjectTrackingAnnotation) isAnnotationValue_ValueType() {}

func (*AnnotationValue_VideoEventAnnotation) isAnnotationValue_ValueType() {}

func (*AnnotationValue_AudioRecognitionAnnotation) isAnnotationValue_ValueType() {}

func (m *AnnotationValue) GetValueType() isAnnotationValue_ValueType {
	if m != nil {
		return m.ValueType
	}
	return nil
}

func (m *AnnotationValue) GetImageClassificationAnnotation() *ImageClassificationAnnotation {
	if x, ok := m.GetValueType().(*AnnotationValue_ImageClassificationAnnotation); ok {
		return x.ImageClassificationAnnotation
	}
	return nil
}

func (m *AnnotationValue) GetImageBoundingPolyAnnotation() *ImageBoundingPolyAnnotation {
	if x, ok := m.GetValueType().(*AnnotationValue_ImageBoundingPolyAnnotation); ok {
		return x.ImageBoundingPolyAnnotation
	}
	return nil
}

func (m *AnnotationValue) GetImagePolylineAnnotation() *ImagePolylineAnnotation {
	if x, ok := m.GetValueType().(*AnnotationValue_ImagePolylineAnnotation); ok {
		return x.ImagePolylineAnnotation
	}
	return nil
}

func (m *AnnotationValue) GetImageSegmentationAnnotation() *ImageSegmentationAnnotation {
	if x, ok := m.GetValueType().(*AnnotationValue_ImageSegmentationAnnotation); ok {
		return x.ImageSegmentationAnnotation
	}
	return nil
}

func (m *AnnotationValue) GetTextClassificationAnnotation() *TextClassificationAnnotation {
	if x, ok := m.GetValueType().(*AnnotationValue_TextClassificationAnnotation); ok {
		return x.TextClassificationAnnotation
	}
	return nil
}

func (m *AnnotationValue) GetVideoClassificationAnnotation() *VideoClassificationAnnotation {
	if x, ok := m.GetValueType().(*AnnotationValue_VideoClassificationAnnotation); ok {
		return x.VideoClassificationAnnotation
	}
	return nil
}

func (m *AnnotationValue) GetVideoObjectTrackingAnnotation() *VideoObjectTrackingAnnotation {
	if x, ok := m.GetValueType().(*AnnotationValue_VideoObjectTrackingAnnotation); ok {
		return x.VideoObjectTrackingAnnotation
	}
	return nil
}

func (m *AnnotationValue) GetVideoEventAnnotation() *VideoEventAnnotation {
	if x, ok := m.GetValueType().(*AnnotationValue_VideoEventAnnotation); ok {
		return x.VideoEventAnnotation
	}
	return nil
}

func (m *AnnotationValue) GetAudioRecognitionAnnotation() *AudioRecognitionAnnotation {
	if x, ok := m.GetValueType().(*AnnotationValue_AudioRecognitionAnnotation); ok {
		return x.AudioRecognitionAnnotation
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AnnotationValue) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AnnotationValue_OneofMarshaler, _AnnotationValue_OneofUnmarshaler, _AnnotationValue_OneofSizer, []interface{}{
		(*AnnotationValue_ImageClassificationAnnotation)(nil),
		(*AnnotationValue_ImageBoundingPolyAnnotation)(nil),
		(*AnnotationValue_ImagePolylineAnnotation)(nil),
		(*AnnotationValue_ImageSegmentationAnnotation)(nil),
		(*AnnotationValue_TextClassificationAnnotation)(nil),
		(*AnnotationValue_VideoClassificationAnnotation)(nil),
		(*AnnotationValue_VideoObjectTrackingAnnotation)(nil),
		(*AnnotationValue_VideoEventAnnotation)(nil),
		(*AnnotationValue_AudioRecognitionAnnotation)(nil),
	}
}

func _AnnotationValue_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AnnotationValue)
	// value_type
	switch x := m.ValueType.(type) {
	case *AnnotationValue_ImageClassificationAnnotation:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImageClassificationAnnotation); err != nil {
			return err
		}
	case *AnnotationValue_ImageBoundingPolyAnnotation:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImageBoundingPolyAnnotation); err != nil {
			return err
		}
	case *AnnotationValue_ImagePolylineAnnotation:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImagePolylineAnnotation); err != nil {
			return err
		}
	case *AnnotationValue_ImageSegmentationAnnotation:
		b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImageSegmentationAnnotation); err != nil {
			return err
		}
	case *AnnotationValue_TextClassificationAnnotation:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TextClassificationAnnotation); err != nil {
			return err
		}
	case *AnnotationValue_VideoClassificationAnnotation:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VideoClassificationAnnotation); err != nil {
			return err
		}
	case *AnnotationValue_VideoObjectTrackingAnnotation:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VideoObjectTrackingAnnotation); err != nil {
			return err
		}
	case *AnnotationValue_VideoEventAnnotation:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VideoEventAnnotation); err != nil {
			return err
		}
	case *AnnotationValue_AudioRecognitionAnnotation:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AudioRecognitionAnnotation); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AnnotationValue.ValueType has unexpected type %T", x)
	}
	return nil
}

func _AnnotationValue_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AnnotationValue)
	switch tag {
	case 1: // value_type.image_classification_annotation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ImageClassificationAnnotation)
		err := b.DecodeMessage(msg)
		m.ValueType = &AnnotationValue_ImageClassificationAnnotation{msg}
		return true, err
	case 2: // value_type.image_bounding_poly_annotation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ImageBoundingPolyAnnotation)
		err := b.DecodeMessage(msg)
		m.ValueType = &AnnotationValue_ImageBoundingPolyAnnotation{msg}
		return true, err
	case 8: // value_type.image_polyline_annotation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ImagePolylineAnnotation)
		err := b.DecodeMessage(msg)
		m.ValueType = &AnnotationValue_ImagePolylineAnnotation{msg}
		return true, err
	case 9: // value_type.image_segmentation_annotation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ImageSegmentationAnnotation)
		err := b.DecodeMessage(msg)
		m.ValueType = &AnnotationValue_ImageSegmentationAnnotation{msg}
		return true, err
	case 3: // value_type.text_classification_annotation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TextClassificationAnnotation)
		err := b.DecodeMessage(msg)
		m.ValueType = &AnnotationValue_TextClassificationAnnotation{msg}
		return true, err
	case 4: // value_type.video_classification_annotation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VideoClassificationAnnotation)
		err := b.DecodeMessage(msg)
		m.ValueType = &AnnotationValue_VideoClassificationAnnotation{msg}
		return true, err
	case 5: // value_type.video_object_tracking_annotation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VideoObjectTrackingAnnotation)
		err := b.DecodeMessage(msg)
		m.ValueType = &AnnotationValue_VideoObjectTrackingAnnotation{msg}
		return true, err
	case 6: // value_type.video_event_annotation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VideoEventAnnotation)
		err := b.DecodeMessage(msg)
		m.ValueType = &AnnotationValue_VideoEventAnnotation{msg}
		return true, err
	case 7: // value_type.audio_recognition_annotation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AudioRecognitionAnnotation)
		err := b.DecodeMessage(msg)
		m.ValueType = &AnnotationValue_AudioRecognitionAnnotation{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AnnotationValue_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AnnotationValue)
	// value_type
	switch x := m.ValueType.(type) {
	case *AnnotationValue_ImageClassificationAnnotation:
		s := proto.Size(x.ImageClassificationAnnotation)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AnnotationValue_ImageBoundingPolyAnnotation:
		s := proto.Size(x.ImageBoundingPolyAnnotation)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AnnotationValue_ImagePolylineAnnotation:
		s := proto.Size(x.ImagePolylineAnnotation)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AnnotationValue_ImageSegmentationAnnotation:
		s := proto.Size(x.ImageSegmentationAnnotation)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AnnotationValue_TextClassificationAnnotation:
		s := proto.Size(x.TextClassificationAnnotation)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AnnotationValue_VideoClassificationAnnotation:
		s := proto.Size(x.VideoClassificationAnnotation)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AnnotationValue_VideoObjectTrackingAnnotation:
		s := proto.Size(x.VideoObjectTrackingAnnotation)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AnnotationValue_VideoEventAnnotation:
		s := proto.Size(x.VideoEventAnnotation)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AnnotationValue_AudioRecognitionAnnotation:
		s := proto.Size(x.AudioRecognitionAnnotation)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Image classification annotation definition.
type ImageClassificationAnnotation struct {
	// Label of image.
	AnnotationSpec       *AnnotationSpec `protobuf:"bytes,1,opt,name=annotation_spec,json=annotationSpec,proto3" json:"annotation_spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ImageClassificationAnnotation) Reset()         { *m = ImageClassificationAnnotation{} }
func (m *ImageClassificationAnnotation) String() string { return proto.CompactTextString(m) }
func (*ImageClassificationAnnotation) ProtoMessage()    {}
func (*ImageClassificationAnnotation) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotation_1df8bdb649b04239, []int{2}
}
func (m *ImageClassificationAnnotation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageClassificationAnnotation.Unmarshal(m, b)
}
func (m *ImageClassificationAnnotation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageClassificationAnnotation.Marshal(b, m, deterministic)
}
func (dst *ImageClassificationAnnotation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageClassificationAnnotation.Merge(dst, src)
}
func (m *ImageClassificationAnnotation) XXX_Size() int {
	return xxx_messageInfo_ImageClassificationAnnotation.Size(m)
}
func (m *ImageClassificationAnnotation) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageClassificationAnnotation.DiscardUnknown(m)
}

var xxx_messageInfo_ImageClassificationAnnotation proto.InternalMessageInfo

func (m *ImageClassificationAnnotation) GetAnnotationSpec() *AnnotationSpec {
	if m != nil {
		return m.AnnotationSpec
	}
	return nil
}

// A vertex represents a 2D point in the image.
// NOTE: the vertex coordinates are in the same scale as the original image.
type Vertex struct {
	// X coordinate.
	X int32 `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	// Y coordinate.
	Y                    int32    `protobuf:"varint,2,opt,name=y,proto3" json:"y,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Vertex) Reset()         { *m = Vertex{} }
func (m *Vertex) String() string { return proto.CompactTextString(m) }
func (*Vertex) ProtoMessage()    {}
func (*Vertex) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotation_1df8bdb649b04239, []int{3}
}
func (m *Vertex) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Vertex.Unmarshal(m, b)
}
func (m *Vertex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Vertex.Marshal(b, m, deterministic)
}
func (dst *Vertex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vertex.Merge(dst, src)
}
func (m *Vertex) XXX_Size() int {
	return xxx_messageInfo_Vertex.Size(m)
}
func (m *Vertex) XXX_DiscardUnknown() {
	xxx_messageInfo_Vertex.DiscardUnknown(m)
}

var xxx_messageInfo_Vertex proto.InternalMessageInfo

func (m *Vertex) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *Vertex) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

// A vertex represents a 2D point in the image.
// NOTE: the normalized vertex coordinates are relative to the original image
// and range from 0 to 1.
type NormalizedVertex struct {
	// X coordinate.
	X float32 `protobuf:"fixed32,1,opt,name=x,proto3" json:"x,omitempty"`
	// Y coordinate.
	Y                    float32  `protobuf:"fixed32,2,opt,name=y,proto3" json:"y,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NormalizedVertex) Reset()         { *m = NormalizedVertex{} }
func (m *NormalizedVertex) String() string { return proto.CompactTextString(m) }
func (*NormalizedVertex) ProtoMessage()    {}
func (*NormalizedVertex) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotation_1df8bdb649b04239, []int{4}
}
func (m *NormalizedVertex) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NormalizedVertex.Unmarshal(m, b)
}
func (m *NormalizedVertex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NormalizedVertex.Marshal(b, m, deterministic)
}
func (dst *NormalizedVertex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NormalizedVertex.Merge(dst, src)
}
func (m *NormalizedVertex) XXX_Size() int {
	return xxx_messageInfo_NormalizedVertex.Size(m)
}
func (m *NormalizedVertex) XXX_DiscardUnknown() {
	xxx_messageInfo_NormalizedVertex.DiscardUnknown(m)
}

var xxx_messageInfo_NormalizedVertex proto.InternalMessageInfo

func (m *NormalizedVertex) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *NormalizedVertex) GetY() float32 {
	if m != nil {
		return m.Y
	}
	return 0
}

// A bounding polygon in the image.
type BoundingPoly struct {
	// The bounding polygon vertices.
	Vertices             []*Vertex `protobuf:"bytes,1,rep,name=vertices,proto3" json:"vertices,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *BoundingPoly) Reset()         { *m = BoundingPoly{} }
func (m *BoundingPoly) String() string { return proto.CompactTextString(m) }
func (*BoundingPoly) ProtoMessage()    {}
func (*BoundingPoly) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotation_1df8bdb649b04239, []int{5}
}
func (m *BoundingPoly) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BoundingPoly.Unmarshal(m, b)
}
func (m *BoundingPoly) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BoundingPoly.Marshal(b, m, deterministic)
}
func (dst *BoundingPoly) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BoundingPoly.Merge(dst, src)
}
func (m *BoundingPoly) XXX_Size() int {
	return xxx_messageInfo_BoundingPoly.Size(m)
}
func (m *BoundingPoly) XXX_DiscardUnknown() {
	xxx_messageInfo_BoundingPoly.DiscardUnknown(m)
}

var xxx_messageInfo_BoundingPoly proto.InternalMessageInfo

func (m *BoundingPoly) GetVertices() []*Vertex {
	if m != nil {
		return m.Vertices
	}
	return nil
}

// Normalized bounding polygon.
type NormalizedBoundingPoly struct {
	// The bounding polygon normalized vertices.
	NormalizedVertices   []*NormalizedVertex `protobuf:"bytes,1,rep,name=normalized_vertices,json=normalizedVertices,proto3" json:"normalized_vertices,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *NormalizedBoundingPoly) Reset()         { *m = NormalizedBoundingPoly{} }
func (m *NormalizedBoundingPoly) String() string { return proto.CompactTextString(m) }
func (*NormalizedBoundingPoly) ProtoMessage()    {}
func (*NormalizedBoundingPoly) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotation_1df8bdb649b04239, []int{6}
}
func (m *NormalizedBoundingPoly) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NormalizedBoundingPoly.Unmarshal(m, b)
}
func (m *NormalizedBoundingPoly) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NormalizedBoundingPoly.Marshal(b, m, deterministic)
}
func (dst *NormalizedBoundingPoly) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NormalizedBoundingPoly.Merge(dst, src)
}
func (m *NormalizedBoundingPoly) XXX_Size() int {
	return xxx_messageInfo_NormalizedBoundingPoly.Size(m)
}
func (m *NormalizedBoundingPoly) XXX_DiscardUnknown() {
	xxx_messageInfo_NormalizedBoundingPoly.DiscardUnknown(m)
}

var xxx_messageInfo_NormalizedBoundingPoly proto.InternalMessageInfo

func (m *NormalizedBoundingPoly) GetNormalizedVertices() []*NormalizedVertex {
	if m != nil {
		return m.NormalizedVertices
	}
	return nil
}

// Image bounding poly annotation. It represents a polygon including
// bounding box in the image.
type ImageBoundingPolyAnnotation struct {
	// The region of the polygon. If it is a bounding box, it is guaranteed to be
	// four points.
	//
	// Types that are valid to be assigned to BoundedArea:
	//	*ImageBoundingPolyAnnotation_BoundingPoly
	//	*ImageBoundingPolyAnnotation_NormalizedBoundingPoly
	BoundedArea isImageBoundingPolyAnnotation_BoundedArea `protobuf_oneof:"bounded_area"`
	// Label of object in this bounding polygon.
	AnnotationSpec       *AnnotationSpec `protobuf:"bytes,1,opt,name=annotation_spec,json=annotationSpec,proto3" json:"annotation_spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ImageBoundingPolyAnnotation) Reset()         { *m = ImageBoundingPolyAnnotation{} }
func (m *ImageBoundingPolyAnnotation) String() string { return proto.CompactTextString(m) }
func (*ImageBoundingPolyAnnotation) ProtoMessage()    {}
func (*ImageBoundingPolyAnnotation) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotation_1df8bdb649b04239, []int{7}
}
func (m *ImageBoundingPolyAnnotation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageBoundingPolyAnnotation.Unmarshal(m, b)
}
func (m *ImageBoundingPolyAnnotation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageBoundingPolyAnnotation.Marshal(b, m, deterministic)
}
func (dst *ImageBoundingPolyAnnotation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageBoundingPolyAnnotation.Merge(dst, src)
}
func (m *ImageBoundingPolyAnnotation) XXX_Size() int {
	return xxx_messageInfo_ImageBoundingPolyAnnotation.Size(m)
}
func (m *ImageBoundingPolyAnnotation) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageBoundingPolyAnnotation.DiscardUnknown(m)
}

var xxx_messageInfo_ImageBoundingPolyAnnotation proto.InternalMessageInfo

type isImageBoundingPolyAnnotation_BoundedArea interface {
	isImageBoundingPolyAnnotation_BoundedArea()
}

type ImageBoundingPolyAnnotation_BoundingPoly struct {
	BoundingPoly *BoundingPoly `protobuf:"bytes,2,opt,name=bounding_poly,json=boundingPoly,proto3,oneof"`
}

type ImageBoundingPolyAnnotation_NormalizedBoundingPoly struct {
	NormalizedBoundingPoly *NormalizedBoundingPoly `protobuf:"bytes,3,opt,name=normalized_bounding_poly,json=normalizedBoundingPoly,proto3,oneof"`
}

func (*ImageBoundingPolyAnnotation_BoundingPoly) isImageBoundingPolyAnnotation_BoundedArea() {}

func (*ImageBoundingPolyAnnotation_NormalizedBoundingPoly) isImageBoundingPolyAnnotation_BoundedArea() {
}

func (m *ImageBoundingPolyAnnotation) GetBoundedArea() isImageBoundingPolyAnnotation_BoundedArea {
	if m != nil {
		return m.BoundedArea
	}
	return nil
}

func (m *ImageBoundingPolyAnnotation) GetBoundingPoly() *BoundingPoly {
	if x, ok := m.GetBoundedArea().(*ImageBoundingPolyAnnotation_BoundingPoly); ok {
		return x.BoundingPoly
	}
	return nil
}

func (m *ImageBoundingPolyAnnotation) GetNormalizedBoundingPoly() *NormalizedBoundingPoly {
	if x, ok := m.GetBoundedArea().(*ImageBoundingPolyAnnotation_NormalizedBoundingPoly); ok {
		return x.NormalizedBoundingPoly
	}
	return nil
}

func (m *ImageBoundingPolyAnnotation) GetAnnotationSpec() *AnnotationSpec {
	if m != nil {
		return m.AnnotationSpec
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ImageBoundingPolyAnnotation) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ImageBoundingPolyAnnotation_OneofMarshaler, _ImageBoundingPolyAnnotation_OneofUnmarshaler, _ImageBoundingPolyAnnotation_OneofSizer, []interface{}{
		(*ImageBoundingPolyAnnotation_BoundingPoly)(nil),
		(*ImageBoundingPolyAnnotation_NormalizedBoundingPoly)(nil),
	}
}

func _ImageBoundingPolyAnnotation_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ImageBoundingPolyAnnotation)
	// bounded_area
	switch x := m.BoundedArea.(type) {
	case *ImageBoundingPolyAnnotation_BoundingPoly:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BoundingPoly); err != nil {
			return err
		}
	case *ImageBoundingPolyAnnotation_NormalizedBoundingPoly:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NormalizedBoundingPoly); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ImageBoundingPolyAnnotation.BoundedArea has unexpected type %T", x)
	}
	return nil
}

func _ImageBoundingPolyAnnotation_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ImageBoundingPolyAnnotation)
	switch tag {
	case 2: // bounded_area.bounding_poly
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BoundingPoly)
		err := b.DecodeMessage(msg)
		m.BoundedArea = &ImageBoundingPolyAnnotation_BoundingPoly{msg}
		return true, err
	case 3: // bounded_area.normalized_bounding_poly
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NormalizedBoundingPoly)
		err := b.DecodeMessage(msg)
		m.BoundedArea = &ImageBoundingPolyAnnotation_NormalizedBoundingPoly{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ImageBoundingPolyAnnotation_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ImageBoundingPolyAnnotation)
	// bounded_area
	switch x := m.BoundedArea.(type) {
	case *ImageBoundingPolyAnnotation_BoundingPoly:
		s := proto.Size(x.BoundingPoly)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ImageBoundingPolyAnnotation_NormalizedBoundingPoly:
		s := proto.Size(x.NormalizedBoundingPoly)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A line with multiple line segments.
type Polyline struct {
	// The polyline vertices.
	Vertices             []*Vertex `protobuf:"bytes,1,rep,name=vertices,proto3" json:"vertices,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Polyline) Reset()         { *m = Polyline{} }
func (m *Polyline) String() string { return proto.CompactTextString(m) }
func (*Polyline) ProtoMessage()    {}
func (*Polyline) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotation_1df8bdb649b04239, []int{8}
}
func (m *Polyline) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Polyline.Unmarshal(m, b)
}
func (m *Polyline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Polyline.Marshal(b, m, deterministic)
}
func (dst *Polyline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Polyline.Merge(dst, src)
}
func (m *Polyline) XXX_Size() int {
	return xxx_messageInfo_Polyline.Size(m)
}
func (m *Polyline) XXX_DiscardUnknown() {
	xxx_messageInfo_Polyline.DiscardUnknown(m)
}

var xxx_messageInfo_Polyline proto.InternalMessageInfo

func (m *Polyline) GetVertices() []*Vertex {
	if m != nil {
		return m.Vertices
	}
	return nil
}

// Normalized polyline.
type NormalizedPolyline struct {
	// The normalized polyline vertices.
	NormalizedVertices   []*NormalizedVertex `protobuf:"bytes,1,rep,name=normalized_vertices,json=normalizedVertices,proto3" json:"normalized_vertices,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *NormalizedPolyline) Reset()         { *m = NormalizedPolyline{} }
func (m *NormalizedPolyline) String() string { return proto.CompactTextString(m) }
func (*NormalizedPolyline) ProtoMessage()    {}
func (*NormalizedPolyline) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotation_1df8bdb649b04239, []int{9}
}
func (m *NormalizedPolyline) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NormalizedPolyline.Unmarshal(m, b)
}
func (m *NormalizedPolyline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NormalizedPolyline.Marshal(b, m, deterministic)
}
func (dst *NormalizedPolyline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NormalizedPolyline.Merge(dst, src)
}
func (m *NormalizedPolyline) XXX_Size() int {
	return xxx_messageInfo_NormalizedPolyline.Size(m)
}
func (m *NormalizedPolyline) XXX_DiscardUnknown() {
	xxx_messageInfo_NormalizedPolyline.DiscardUnknown(m)
}

var xxx_messageInfo_NormalizedPolyline proto.InternalMessageInfo

func (m *NormalizedPolyline) GetNormalizedVertices() []*NormalizedVertex {
	if m != nil {
		return m.NormalizedVertices
	}
	return nil
}

// A polyline for the image annotation.
type ImagePolylineAnnotation struct {
	// Types that are valid to be assigned to Poly:
	//	*ImagePolylineAnnotation_Polyline
	//	*ImagePolylineAnnotation_NormalizedPolyline
	Poly isImagePolylineAnnotation_Poly `protobuf_oneof:"poly"`
	// Label of this polyline.
	AnnotationSpec       *AnnotationSpec `protobuf:"bytes,1,opt,name=annotation_spec,json=annotationSpec,proto3" json:"annotation_spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ImagePolylineAnnotation) Reset()         { *m = ImagePolylineAnnotation{} }
func (m *ImagePolylineAnnotation) String() string { return proto.CompactTextString(m) }
func (*ImagePolylineAnnotation) ProtoMessage()    {}
func (*ImagePolylineAnnotation) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotation_1df8bdb649b04239, []int{10}
}
func (m *ImagePolylineAnnotation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImagePolylineAnnotation.Unmarshal(m, b)
}
func (m *ImagePolylineAnnotation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImagePolylineAnnotation.Marshal(b, m, deterministic)
}
func (dst *ImagePolylineAnnotation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImagePolylineAnnotation.Merge(dst, src)
}
func (m *ImagePolylineAnnotation) XXX_Size() int {
	return xxx_messageInfo_ImagePolylineAnnotation.Size(m)
}
func (m *ImagePolylineAnnotation) XXX_DiscardUnknown() {
	xxx_messageInfo_ImagePolylineAnnotation.DiscardUnknown(m)
}

var xxx_messageInfo_ImagePolylineAnnotation proto.InternalMessageInfo

type isImagePolylineAnnotation_Poly interface {
	isImagePolylineAnnotation_Poly()
}

type ImagePolylineAnnotation_Polyline struct {
	Polyline *Polyline `protobuf:"bytes,2,opt,name=polyline,proto3,oneof"`
}

type ImagePolylineAnnotation_NormalizedPolyline struct {
	NormalizedPolyline *NormalizedPolyline `protobuf:"bytes,3,opt,name=normalized_polyline,json=normalizedPolyline,proto3,oneof"`
}

func (*ImagePolylineAnnotation_Polyline) isImagePolylineAnnotation_Poly() {}

func (*ImagePolylineAnnotation_NormalizedPolyline) isImagePolylineAnnotation_Poly() {}

func (m *ImagePolylineAnnotation) GetPoly() isImagePolylineAnnotation_Poly {
	if m != nil {
		return m.Poly
	}
	return nil
}

func (m *ImagePolylineAnnotation) GetPolyline() *Polyline {
	if x, ok := m.GetPoly().(*ImagePolylineAnnotation_Polyline); ok {
		return x.Polyline
	}
	return nil
}

func (m *ImagePolylineAnnotation) GetNormalizedPolyline() *NormalizedPolyline {
	if x, ok := m.GetPoly().(*ImagePolylineAnnotation_NormalizedPolyline); ok {
		return x.NormalizedPolyline
	}
	return nil
}

func (m *ImagePolylineAnnotation) GetAnnotationSpec() *AnnotationSpec {
	if m != nil {
		return m.AnnotationSpec
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ImagePolylineAnnotation) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ImagePolylineAnnotation_OneofMarshaler, _ImagePolylineAnnotation_OneofUnmarshaler, _ImagePolylineAnnotation_OneofSizer, []interface{}{
		(*ImagePolylineAnnotation_Polyline)(nil),
		(*ImagePolylineAnnotation_NormalizedPolyline)(nil),
	}
}

func _ImagePolylineAnnotation_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ImagePolylineAnnotation)
	// poly
	switch x := m.Poly.(type) {
	case *ImagePolylineAnnotation_Polyline:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Polyline); err != nil {
			return err
		}
	case *ImagePolylineAnnotation_NormalizedPolyline:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NormalizedPolyline); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ImagePolylineAnnotation.Poly has unexpected type %T", x)
	}
	return nil
}

func _ImagePolylineAnnotation_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ImagePolylineAnnotation)
	switch tag {
	case 2: // poly.polyline
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Polyline)
		err := b.DecodeMessage(msg)
		m.Poly = &ImagePolylineAnnotation_Polyline{msg}
		return true, err
	case 3: // poly.normalized_polyline
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NormalizedPolyline)
		err := b.DecodeMessage(msg)
		m.Poly = &ImagePolylineAnnotation_NormalizedPolyline{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ImagePolylineAnnotation_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ImagePolylineAnnotation)
	// poly
	switch x := m.Poly.(type) {
	case *ImagePolylineAnnotation_Polyline:
		s := proto.Size(x.Polyline)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ImagePolylineAnnotation_NormalizedPolyline:
		s := proto.Size(x.NormalizedPolyline)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Image segmentation annotation.
type ImageSegmentationAnnotation struct {
	// The mapping between rgb color and annotation spec. The key is the rgb
	// color represented in format of rgb(0, 0, 0). The value is the
	// AnnotationSpec.
	AnnotationColors map[string]*AnnotationSpec `protobuf:"bytes,1,rep,name=annotation_colors,json=annotationColors,proto3" json:"annotation_colors,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Image format.
	MimeType string `protobuf:"bytes,2,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	// A byte string of a full image's color map.
	ImageBytes           []byte   `protobuf:"bytes,3,opt,name=image_bytes,json=imageBytes,proto3" json:"image_bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImageSegmentationAnnotation) Reset()         { *m = ImageSegmentationAnnotation{} }
func (m *ImageSegmentationAnnotation) String() string { return proto.CompactTextString(m) }
func (*ImageSegmentationAnnotation) ProtoMessage()    {}
func (*ImageSegmentationAnnotation) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotation_1df8bdb649b04239, []int{11}
}
func (m *ImageSegmentationAnnotation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageSegmentationAnnotation.Unmarshal(m, b)
}
func (m *ImageSegmentationAnnotation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageSegmentationAnnotation.Marshal(b, m, deterministic)
}
func (dst *ImageSegmentationAnnotation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageSegmentationAnnotation.Merge(dst, src)
}
func (m *ImageSegmentationAnnotation) XXX_Size() int {
	return xxx_messageInfo_ImageSegmentationAnnotation.Size(m)
}
func (m *ImageSegmentationAnnotation) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageSegmentationAnnotation.DiscardUnknown(m)
}

var xxx_messageInfo_ImageSegmentationAnnotation proto.InternalMessageInfo

func (m *ImageSegmentationAnnotation) GetAnnotationColors() map[string]*AnnotationSpec {
	if m != nil {
		return m.AnnotationColors
	}
	return nil
}

func (m *ImageSegmentationAnnotation) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *ImageSegmentationAnnotation) GetImageBytes() []byte {
	if m != nil {
		return m.ImageBytes
	}
	return nil
}

// Text classification annotation.
type TextClassificationAnnotation struct {
	// Label of the text.
	AnnotationSpec       *AnnotationSpec `protobuf:"bytes,1,opt,name=annotation_spec,json=annotationSpec,proto3" json:"annotation_spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *TextClassificationAnnotation) Reset()         { *m = TextClassificationAnnotation{} }
func (m *TextClassificationAnnotation) String() string { return proto.CompactTextString(m) }
func (*TextClassificationAnnotation) ProtoMessage()    {}
func (*TextClassificationAnnotation) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotation_1df8bdb649b04239, []int{12}
}
func (m *TextClassificationAnnotation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TextClassificationAnnotation.Unmarshal(m, b)
}
func (m *TextClassificationAnnotation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TextClassificationAnnotation.Marshal(b, m, deterministic)
}
func (dst *TextClassificationAnnotation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TextClassificationAnnotation.Merge(dst, src)
}
func (m *TextClassificationAnnotation) XXX_Size() int {
	return xxx_messageInfo_TextClassificationAnnotation.Size(m)
}
func (m *TextClassificationAnnotation) XXX_DiscardUnknown() {
	xxx_messageInfo_TextClassificationAnnotation.DiscardUnknown(m)
}

var xxx_messageInfo_TextClassificationAnnotation proto.InternalMessageInfo

func (m *TextClassificationAnnotation) GetAnnotationSpec() *AnnotationSpec {
	if m != nil {
		return m.AnnotationSpec
	}
	return nil
}

// A time period inside of an example that has a time dimension (e.g. video).
type TimeSegment struct {
	// Start of the time segment (inclusive), represented as the duration since
	// the example start.
	StartTimeOffset *duration.Duration `protobuf:"bytes,1,opt,name=start_time_offset,json=startTimeOffset,proto3" json:"start_time_offset,omitempty"`
	// End of the time segment (exclusive), represented as the duration since the
	// example start.
	EndTimeOffset        *duration.Duration `protobuf:"bytes,2,opt,name=end_time_offset,json=endTimeOffset,proto3" json:"end_time_offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TimeSegment) Reset()         { *m = TimeSegment{} }
func (m *TimeSegment) String() string { return proto.CompactTextString(m) }
func (*TimeSegment) ProtoMessage()    {}
func (*TimeSegment) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotation_1df8bdb649b04239, []int{13}
}
func (m *TimeSegment) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TimeSegment.Unmarshal(m, b)
}
func (m *TimeSegment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TimeSegment.Marshal(b, m, deterministic)
}
func (dst *TimeSegment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeSegment.Merge(dst, src)
}
func (m *TimeSegment) XXX_Size() int {
	return xxx_messageInfo_TimeSegment.Size(m)
}
func (m *TimeSegment) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeSegment.DiscardUnknown(m)
}

var xxx_messageInfo_TimeSegment proto.InternalMessageInfo

func (m *TimeSegment) GetStartTimeOffset() *duration.Duration {
	if m != nil {
		return m.StartTimeOffset
	}
	return nil
}

func (m *TimeSegment) GetEndTimeOffset() *duration.Duration {
	if m != nil {
		return m.EndTimeOffset
	}
	return nil
}

// Video classification annotation.
type VideoClassificationAnnotation struct {
	// The time segment of the video to which the annotation applies.
	TimeSegment *TimeSegment `protobuf:"bytes,1,opt,name=time_segment,json=timeSegment,proto3" json:"time_segment,omitempty"`
	// Label of the segment specified by time_segment.
	AnnotationSpec       *AnnotationSpec `protobuf:"bytes,2,opt,name=annotation_spec,json=annotationSpec,proto3" json:"annotation_spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *VideoClassificationAnnotation) Reset()         { *m = VideoClassificationAnnotation{} }
func (m *VideoClassificationAnnotation) String() string { return proto.CompactTextString(m) }
func (*VideoClassificationAnnotation) ProtoMessage()    {}
func (*VideoClassificationAnnotation) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotation_1df8bdb649b04239, []int{14}
}
func (m *VideoClassificationAnnotation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VideoClassificationAnnotation.Unmarshal(m, b)
}
func (m *VideoClassificationAnnotation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VideoClassificationAnnotation.Marshal(b, m, deterministic)
}
func (dst *VideoClassificationAnnotation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoClassificationAnnotation.Merge(dst, src)
}
func (m *VideoClassificationAnnotation) XXX_Size() int {
	return xxx_messageInfo_VideoClassificationAnnotation.Size(m)
}
func (m *VideoClassificationAnnotation) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoClassificationAnnotation.DiscardUnknown(m)
}

var xxx_messageInfo_VideoClassificationAnnotation proto.InternalMessageInfo

func (m *VideoClassificationAnnotation) GetTimeSegment() *TimeSegment {
	if m != nil {
		return m.TimeSegment
	}
	return nil
}

func (m *VideoClassificationAnnotation) GetAnnotationSpec() *AnnotationSpec {
	if m != nil {
		return m.AnnotationSpec
	}
	return nil
}

// Video frame level annotation for object detection and tracking.
type ObjectTrackingFrame struct {
	// The bounding box location of this object track for the frame.
	//
	// Types that are valid to be assigned to BoundedArea:
	//	*ObjectTrackingFrame_BoundingPoly
	//	*ObjectTrackingFrame_NormalizedBoundingPoly
	BoundedArea isObjectTrackingFrame_BoundedArea `protobuf_oneof:"bounded_area"`
	// The time offset of this frame relative to the beginning of the video.
	TimeOffset           *duration.Duration `protobuf:"bytes,3,opt,name=time_offset,json=timeOffset,proto3" json:"time_offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ObjectTrackingFrame) Reset()         { *m = ObjectTrackingFrame{} }
func (m *ObjectTrackingFrame) String() string { return proto.CompactTextString(m) }
func (*ObjectTrackingFrame) ProtoMessage()    {}
func (*ObjectTrackingFrame) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotation_1df8bdb649b04239, []int{15}
}
func (m *ObjectTrackingFrame) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ObjectTrackingFrame.Unmarshal(m, b)
}
func (m *ObjectTrackingFrame) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ObjectTrackingFrame.Marshal(b, m, deterministic)
}
func (dst *ObjectTrackingFrame) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectTrackingFrame.Merge(dst, src)
}
func (m *ObjectTrackingFrame) XXX_Size() int {
	return xxx_messageInfo_ObjectTrackingFrame.Size(m)
}
func (m *ObjectTrackingFrame) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectTrackingFrame.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectTrackingFrame proto.InternalMessageInfo

type isObjectTrackingFrame_BoundedArea interface {
	isObjectTrackingFrame_BoundedArea()
}

type ObjectTrackingFrame_BoundingPoly struct {
	BoundingPoly *BoundingPoly `protobuf:"bytes,1,opt,name=bounding_poly,json=boundingPoly,proto3,oneof"`
}

type ObjectTrackingFrame_NormalizedBoundingPoly struct {
	NormalizedBoundingPoly *NormalizedBoundingPoly `protobuf:"bytes,2,opt,name=normalized_bounding_poly,json=normalizedBoundingPoly,proto3,oneof"`
}

func (*ObjectTrackingFrame_BoundingPoly) isObjectTrackingFrame_BoundedArea() {}

func (*ObjectTrackingFrame_NormalizedBoundingPoly) isObjectTrackingFrame_BoundedArea() {}

func (m *ObjectTrackingFrame) GetBoundedArea() isObjectTrackingFrame_BoundedArea {
	if m != nil {
		return m.BoundedArea
	}
	return nil
}

func (m *ObjectTrackingFrame) GetBoundingPoly() *BoundingPoly {
	if x, ok := m.GetBoundedArea().(*ObjectTrackingFrame_BoundingPoly); ok {
		return x.BoundingPoly
	}
	return nil
}

func (m *ObjectTrackingFrame) GetNormalizedBoundingPoly() *NormalizedBoundingPoly {
	if x, ok := m.GetBoundedArea().(*ObjectTrackingFrame_NormalizedBoundingPoly); ok {
		return x.NormalizedBoundingPoly
	}
	return nil
}

func (m *ObjectTrackingFrame) GetTimeOffset() *duration.Duration {
	if m != nil {
		return m.TimeOffset
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ObjectTrackingFrame) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ObjectTrackingFrame_OneofMarshaler, _ObjectTrackingFrame_OneofUnmarshaler, _ObjectTrackingFrame_OneofSizer, []interface{}{
		(*ObjectTrackingFrame_BoundingPoly)(nil),
		(*ObjectTrackingFrame_NormalizedBoundingPoly)(nil),
	}
}

func _ObjectTrackingFrame_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ObjectTrackingFrame)
	// bounded_area
	switch x := m.BoundedArea.(type) {
	case *ObjectTrackingFrame_BoundingPoly:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BoundingPoly); err != nil {
			return err
		}
	case *ObjectTrackingFrame_NormalizedBoundingPoly:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NormalizedBoundingPoly); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ObjectTrackingFrame.BoundedArea has unexpected type %T", x)
	}
	return nil
}

func _ObjectTrackingFrame_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ObjectTrackingFrame)
	switch tag {
	case 1: // bounded_area.bounding_poly
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BoundingPoly)
		err := b.DecodeMessage(msg)
		m.BoundedArea = &ObjectTrackingFrame_BoundingPoly{msg}
		return true, err
	case 2: // bounded_area.normalized_bounding_poly
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NormalizedBoundingPoly)
		err := b.DecodeMessage(msg)
		m.BoundedArea = &ObjectTrackingFrame_NormalizedBoundingPoly{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ObjectTrackingFrame_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ObjectTrackingFrame)
	// bounded_area
	switch x := m.BoundedArea.(type) {
	case *ObjectTrackingFrame_BoundingPoly:
		s := proto.Size(x.BoundingPoly)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ObjectTrackingFrame_NormalizedBoundingPoly:
		s := proto.Size(x.NormalizedBoundingPoly)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Video object tracking annotation.
type VideoObjectTrackingAnnotation struct {
	// Label of the object tracked in this annotation.
	AnnotationSpec *AnnotationSpec `protobuf:"bytes,1,opt,name=annotation_spec,json=annotationSpec,proto3" json:"annotation_spec,omitempty"`
	// The time segment of the video to which object tracking applies.
	TimeSegment *TimeSegment `protobuf:"bytes,2,opt,name=time_segment,json=timeSegment,proto3" json:"time_segment,omitempty"`
	// The list of frames where this object track appears.
	ObjectTrackingFrames []*ObjectTrackingFrame `protobuf:"bytes,3,rep,name=object_tracking_frames,json=objectTrackingFrames,proto3" json:"object_tracking_frames,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *VideoObjectTrackingAnnotation) Reset()         { *m = VideoObjectTrackingAnnotation{} }
func (m *VideoObjectTrackingAnnotation) String() string { return proto.CompactTextString(m) }
func (*VideoObjectTrackingAnnotation) ProtoMessage()    {}
func (*VideoObjectTrackingAnnotation) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotation_1df8bdb649b04239, []int{16}
}
func (m *VideoObjectTrackingAnnotation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VideoObjectTrackingAnnotation.Unmarshal(m, b)
}
func (m *VideoObjectTrackingAnnotation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VideoObjectTrackingAnnotation.Marshal(b, m, deterministic)
}
func (dst *VideoObjectTrackingAnnotation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoObjectTrackingAnnotation.Merge(dst, src)
}
func (m *VideoObjectTrackingAnnotation) XXX_Size() int {
	return xxx_messageInfo_VideoObjectTrackingAnnotation.Size(m)
}
func (m *VideoObjectTrackingAnnotation) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoObjectTrackingAnnotation.DiscardUnknown(m)
}

var xxx_messageInfo_VideoObjectTrackingAnnotation proto.InternalMessageInfo

func (m *VideoObjectTrackingAnnotation) GetAnnotationSpec() *AnnotationSpec {
	if m != nil {
		return m.AnnotationSpec
	}
	return nil
}

func (m *VideoObjectTrackingAnnotation) GetTimeSegment() *TimeSegment {
	if m != nil {
		return m.TimeSegment
	}
	return nil
}

func (m *VideoObjectTrackingAnnotation) GetObjectTrackingFrames() []*ObjectTrackingFrame {
	if m != nil {
		return m.ObjectTrackingFrames
	}
	return nil
}

// Video event annotation.
type VideoEventAnnotation struct {
	// Label of the event in this annotation.
	AnnotationSpec *AnnotationSpec `protobuf:"bytes,1,opt,name=annotation_spec,json=annotationSpec,proto3" json:"annotation_spec,omitempty"`
	// The time segment of the video to which the annotation applies.
	TimeSegment          *TimeSegment `protobuf:"bytes,2,opt,name=time_segment,json=timeSegment,proto3" json:"time_segment,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *VideoEventAnnotation) Reset()         { *m = VideoEventAnnotation{} }
func (m *VideoEventAnnotation) String() string { return proto.CompactTextString(m) }
func (*VideoEventAnnotation) ProtoMessage()    {}
func (*VideoEventAnnotation) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotation_1df8bdb649b04239, []int{17}
}
func (m *VideoEventAnnotation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VideoEventAnnotation.Unmarshal(m, b)
}
func (m *VideoEventAnnotation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VideoEventAnnotation.Marshal(b, m, deterministic)
}
func (dst *VideoEventAnnotation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoEventAnnotation.Merge(dst, src)
}
func (m *VideoEventAnnotation) XXX_Size() int {
	return xxx_messageInfo_VideoEventAnnotation.Size(m)
}
func (m *VideoEventAnnotation) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoEventAnnotation.DiscardUnknown(m)
}

var xxx_messageInfo_VideoEventAnnotation proto.InternalMessageInfo

func (m *VideoEventAnnotation) GetAnnotationSpec() *AnnotationSpec {
	if m != nil {
		return m.AnnotationSpec
	}
	return nil
}

func (m *VideoEventAnnotation) GetTimeSegment() *TimeSegment {
	if m != nil {
		return m.TimeSegment
	}
	return nil
}

// Speech audio recognition.
type AudioRecognitionAnnotation struct {
	// Transcript text representing the words spoken.
	Transcript string `protobuf:"bytes,1,opt,name=transcript,proto3" json:"transcript,omitempty"`
	// Start position in audio file that the transcription corresponds to.
	StartOffset *duration.Duration `protobuf:"bytes,2,opt,name=start_offset,json=startOffset,proto3" json:"start_offset,omitempty"`
	// End position in audio file that the transcription corresponds to.
	EndOffset            *duration.Duration `protobuf:"bytes,3,opt,name=end_offset,json=endOffset,proto3" json:"end_offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *AudioRecognitionAnnotation) Reset()         { *m = AudioRecognitionAnnotation{} }
func (m *AudioRecognitionAnnotation) String() string { return proto.CompactTextString(m) }
func (*AudioRecognitionAnnotation) ProtoMessage()    {}
func (*AudioRecognitionAnnotation) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotation_1df8bdb649b04239, []int{18}
}
func (m *AudioRecognitionAnnotation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AudioRecognitionAnnotation.Unmarshal(m, b)
}
func (m *AudioRecognitionAnnotation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AudioRecognitionAnnotation.Marshal(b, m, deterministic)
}
func (dst *AudioRecognitionAnnotation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AudioRecognitionAnnotation.Merge(dst, src)
}
func (m *AudioRecognitionAnnotation) XXX_Size() int {
	return xxx_messageInfo_AudioRecognitionAnnotation.Size(m)
}
func (m *AudioRecognitionAnnotation) XXX_DiscardUnknown() {
	xxx_messageInfo_AudioRecognitionAnnotation.DiscardUnknown(m)
}

var xxx_messageInfo_AudioRecognitionAnnotation proto.InternalMessageInfo

func (m *AudioRecognitionAnnotation) GetTranscript() string {
	if m != nil {
		return m.Transcript
	}
	return ""
}

func (m *AudioRecognitionAnnotation) GetStartOffset() *duration.Duration {
	if m != nil {
		return m.StartOffset
	}
	return nil
}

func (m *AudioRecognitionAnnotation) GetEndOffset() *duration.Duration {
	if m != nil {
		return m.EndOffset
	}
	return nil
}

// Additional information associated with the annotation.
type AnnotationMetadata struct {
	// Metadata related to human labeling.
	OperatorMetadata     *OperatorMetadata `protobuf:"bytes,2,opt,name=operator_metadata,json=operatorMetadata,proto3" json:"operator_metadata,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *AnnotationMetadata) Reset()         { *m = AnnotationMetadata{} }
func (m *AnnotationMetadata) String() string { return proto.CompactTextString(m) }
func (*AnnotationMetadata) ProtoMessage()    {}
func (*AnnotationMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotation_1df8bdb649b04239, []int{19}
}
func (m *AnnotationMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AnnotationMetadata.Unmarshal(m, b)
}
func (m *AnnotationMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AnnotationMetadata.Marshal(b, m, deterministic)
}
func (dst *AnnotationMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnnotationMetadata.Merge(dst, src)
}
func (m *AnnotationMetadata) XXX_Size() int {
	return xxx_messageInfo_AnnotationMetadata.Size(m)
}
func (m *AnnotationMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_AnnotationMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_AnnotationMetadata proto.InternalMessageInfo

func (m *AnnotationMetadata) GetOperatorMetadata() *OperatorMetadata {
	if m != nil {
		return m.OperatorMetadata
	}
	return nil
}

// General information useful for labels coming from contributors.
type OperatorMetadata struct {
	// Confidence score corresponding to a label. For examle, if 3 contributors
	// have answered the question and 2 of them agree on the final label, the
	// confidence score will be 0.67 (2/3).
	Score float32 `protobuf:"fixed32,1,opt,name=score,proto3" json:"score,omitempty"`
	// The total number of contributors that answer this question.
	TotalVotes int32 `protobuf:"varint,2,opt,name=total_votes,json=totalVotes,proto3" json:"total_votes,omitempty"`
	// The total number of contributors that choose this label.
	LabelVotes           int32    `protobuf:"varint,3,opt,name=label_votes,json=labelVotes,proto3" json:"label_votes,omitempty"`
	Comments             []string `protobuf:"bytes,4,rep,name=comments,proto3" json:"comments,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OperatorMetadata) Reset()         { *m = OperatorMetadata{} }
func (m *OperatorMetadata) String() string { return proto.CompactTextString(m) }
func (*OperatorMetadata) ProtoMessage()    {}
func (*OperatorMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_annotation_1df8bdb649b04239, []int{20}
}
func (m *OperatorMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OperatorMetadata.Unmarshal(m, b)
}
func (m *OperatorMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OperatorMetadata.Marshal(b, m, deterministic)
}
func (dst *OperatorMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperatorMetadata.Merge(dst, src)
}
func (m *OperatorMetadata) XXX_Size() int {
	return xxx_messageInfo_OperatorMetadata.Size(m)
}
func (m *OperatorMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_OperatorMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_OperatorMetadata proto.InternalMessageInfo

func (m *OperatorMetadata) GetScore() float32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *OperatorMetadata) GetTotalVotes() int32 {
	if m != nil {
		return m.TotalVotes
	}
	return 0
}

func (m *OperatorMetadata) GetLabelVotes() int32 {
	if m != nil {
		return m.LabelVotes
	}
	return 0
}

func (m *OperatorMetadata) GetComments() []string {
	if m != nil {
		return m.Comments
	}
	return nil
}

func init() {
	proto.RegisterType((*Annotation)(nil), "google.cloud.datalabeling.v1beta1.Annotation")
	proto.RegisterType((*AnnotationValue)(nil), "google.cloud.datalabeling.v1beta1.AnnotationValue")
	proto.RegisterType((*ImageClassificationAnnotation)(nil), "google.cloud.datalabeling.v1beta1.ImageClassificationAnnotation")
	proto.RegisterType((*Vertex)(nil), "google.cloud.datalabeling.v1beta1.Vertex")
	proto.RegisterType((*NormalizedVertex)(nil), "google.cloud.datalabeling.v1beta1.NormalizedVertex")
	proto.RegisterType((*BoundingPoly)(nil), "google.cloud.datalabeling.v1beta1.BoundingPoly")
	proto.RegisterType((*NormalizedBoundingPoly)(nil), "google.cloud.datalabeling.v1beta1.NormalizedBoundingPoly")
	proto.RegisterType((*ImageBoundingPolyAnnotation)(nil), "google.cloud.datalabeling.v1beta1.ImageBoundingPolyAnnotation")
	proto.RegisterType((*Polyline)(nil), "google.cloud.datalabeling.v1beta1.Polyline")
	proto.RegisterType((*NormalizedPolyline)(nil), "google.cloud.datalabeling.v1beta1.NormalizedPolyline")
	proto.RegisterType((*ImagePolylineAnnotation)(nil), "google.cloud.datalabeling.v1beta1.ImagePolylineAnnotation")
	proto.RegisterType((*ImageSegmentationAnnotation)(nil), "google.cloud.datalabeling.v1beta1.ImageSegmentationAnnotation")
	proto.RegisterMapType((map[string]*AnnotationSpec)(nil), "google.cloud.datalabeling.v1beta1.ImageSegmentationAnnotation.AnnotationColorsEntry")
	proto.RegisterType((*TextClassificationAnnotation)(nil), "google.cloud.datalabeling.v1beta1.TextClassificationAnnotation")
	proto.RegisterType((*TimeSegment)(nil), "google.cloud.datalabeling.v1beta1.TimeSegment")
	proto.RegisterType((*VideoClassificationAnnotation)(nil), "google.cloud.datalabeling.v1beta1.VideoClassificationAnnotation")
	proto.RegisterType((*ObjectTrackingFrame)(nil), "google.cloud.datalabeling.v1beta1.ObjectTrackingFrame")
	proto.RegisterType((*VideoObjectTrackingAnnotation)(nil), "google.cloud.datalabeling.v1beta1.VideoObjectTrackingAnnotation")
	proto.RegisterType((*VideoEventAnnotation)(nil), "google.cloud.datalabeling.v1beta1.VideoEventAnnotation")
	proto.RegisterType((*AudioRecognitionAnnotation)(nil), "google.cloud.datalabeling.v1beta1.AudioRecognitionAnnotation")
	proto.RegisterType((*AnnotationMetadata)(nil), "google.cloud.datalabeling.v1beta1.AnnotationMetadata")
	proto.RegisterType((*OperatorMetadata)(nil), "google.cloud.datalabeling.v1beta1.OperatorMetadata")
	proto.RegisterEnum("google.cloud.datalabeling.v1beta1.AnnotationSource", AnnotationSource_name, AnnotationSource_value)
	proto.RegisterEnum("google.cloud.datalabeling.v1beta1.AnnotationSentiment", AnnotationSentiment_name, AnnotationSentiment_value)
	proto.RegisterEnum("google.cloud.datalabeling.v1beta1.AnnotationType", AnnotationType_name, AnnotationType_value)
}

func init() {
	proto.RegisterFile("google/cloud/datalabeling/v1beta1/annotation.proto", fileDescriptor_annotation_1df8bdb649b04239)
}

var fileDescriptor_annotation_1df8bdb649b04239 = []byte{
	// 1630 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x58, 0xdd, 0x6f, 0xdb, 0x46,
	0x12, 0x37, 0x29, 0xdb, 0x91, 0x47, 0x8a, 0xad, 0xac, 0x7d, 0x8e, 0x22, 0x7f, 0x46, 0x97, 0x1c,
	0x1c, 0x1f, 0x20, 0x21, 0x0e, 0xee, 0x2e, 0x97, 0xdc, 0x97, 0x2c, 0x33, 0x36, 0xaf, 0xb1, 0xa8,
	0x50, 0xb4, 0x9a, 0x04, 0x28, 0x18, 0x9a, 0x5a, 0xab, 0x6c, 0x24, 0x52, 0x20, 0x57, 0x82, 0x95,
	0x02, 0x05, 0x02, 0xf4, 0x03, 0x68, 0x81, 0xbe, 0xf6, 0xdf, 0x28, 0x8a, 0x3c, 0xf6, 0xb5, 0xaf,
	0xed, 0x63, 0xfb, 0xe7, 0x14, 0xbb, 0xa4, 0x24, 0x92, 0xfa, 0x30, 0xd5, 0xc4, 0x05, 0xfa, 0xa6,
	0x9d, 0x9d, 0xf9, 0xcd, 0x6f, 0x67, 0x47, 0x33, 0xb3, 0x84, 0xbd, 0xba, 0x65, 0xd5, 0x1b, 0x38,
	0xaf, 0x37, 0xac, 0x76, 0x2d, 0x5f, 0xd3, 0x88, 0xd6, 0xd0, 0x4e, 0x71, 0xc3, 0x30, 0xeb, 0xf9,
	0xce, 0xdd, 0x53, 0x4c, 0xb4, 0xbb, 0x79, 0xcd, 0x34, 0x2d, 0xa2, 0x11, 0xc3, 0x32, 0x73, 0x2d,
	0xdb, 0x22, 0x16, 0xba, 0xe9, 0xda, 0xe4, 0x98, 0x4d, 0xce, 0x6f, 0x93, 0xf3, 0x6c, 0x32, 0x0f,
	0xa7, 0x81, 0x55, 0x9d, 0x16, 0xd6, 0x55, 0x07, 0x13, 0x17, 0x3f, 0xb3, 0xe9, 0x19, 0xb3, 0xd5,
	0x69, 0xfb, 0x2c, 0x5f, 0x6b, 0xdb, 0x3e, 0xff, 0x99, 0xf5, 0xf0, 0xbe, 0x43, 0xec, 0xb6, 0xde,
	0xb3, 0xde, 0x0a, 0xef, 0x12, 0xa3, 0x89, 0x1d, 0xa2, 0x35, 0x5b, 0x21, 0x73, 0xad, 0x65, 0xf8,
	0x48, 0x38, 0xee, 0x6e, 0xf6, 0x4d, 0x0c, 0xa0, 0xd0, 0x97, 0x22, 0x04, 0xb3, 0xa6, 0xd6, 0xc4,
	0x69, 0x6e, 0x9b, 0xdb, 0x59, 0x90, 0xd9, 0x6f, 0xf4, 0x02, 0xae, 0xf9, 0xc9, 0x5b, 0x6d, 0x5b,
	0xc7, 0x69, 0x7e, 0x9b, 0xdb, 0x59, 0xdc, 0xbb, 0x97, 0xbb, 0x30, 0x36, 0xb9, 0x01, 0x7a, 0x85,
	0x99, 0xca, 0x29, 0x2d, 0x24, 0x41, 0x1f, 0x80, 0x4f, 0xa6, 0x76, 0xb4, 0x46, 0x1b, 0xa7, 0x63,
	0xdb, 0xdc, 0x4e, 0x62, 0x6f, 0x6f, 0x2a, 0x07, 0x55, 0x6a, 0x29, 0x2f, 0x69, 0x41, 0x01, 0x3a,
	0x83, 0x65, 0x1f, 0x7c, 0x13, 0x13, 0x8d, 0xe2, 0xa4, 0x67, 0x99, 0x87, 0xbf, 0x4d, 0xe5, 0xe1,
	0xd8, 0x33, 0x96, 0x91, 0x36, 0x24, 0x43, 0x06, 0xac, 0xf8, 0x03, 0x85, 0x4d, 0x7a, 0x15, 0x26,
	0x49, 0xcf, 0xb3, 0x58, 0xfd, 0x7d, 0xba, 0x58, 0xf5, 0xac, 0x65, 0x1f, 0xf7, 0xbe, 0x30, 0xfb,
	0xd3, 0x02, 0x2c, 0x85, 0xce, 0x8d, 0xbe, 0xe4, 0x60, 0xcb, 0x68, 0x6a, 0x75, 0xac, 0xea, 0x0d,
	0xcd, 0x71, 0x8c, 0x33, 0x43, 0x77, 0x99, 0x0c, 0x00, 0xd8, 0xbd, 0x26, 0xf6, 0xfe, 0x17, 0x81,
	0x8a, 0x48, 0x91, 0x8a, 0x01, 0xa0, 0x81, 0xc3, 0xa3, 0x19, 0x79, 0xc3, 0x98, 0xa4, 0x80, 0x3e,
	0xe3, 0x60, 0xd3, 0x25, 0x73, 0x6a, 0xb5, 0xcd, 0x9a, 0x61, 0xd6, 0xd5, 0x96, 0xd5, 0xe8, 0xfa,
	0xb9, 0xf0, 0x8c, 0xcb, 0x7f, 0xa2, 0x72, 0xd9, 0xf7, 0x70, 0xca, 0x56, 0xa3, 0x1b, 0x60, 0xb2,
	0x66, 0x8c, 0xdf, 0x46, 0xe7, 0x70, 0xc3, 0xa5, 0x41, 0xbd, 0x37, 0x0c, 0x13, 0xfb, 0x19, 0xc4,
	0x19, 0x83, 0x07, 0x51, 0x19, 0x94, 0x3d, 0x88, 0x80, 0xf7, 0xeb, 0xc6, 0xe8, 0x2d, 0xf4, 0x29,
	0x07, 0x6e, 0x8c, 0x54, 0x07, 0xd7, 0xe9, 0xa5, 0x0d, 0x5d, 0xc6, 0xc2, 0x74, 0x01, 0xa8, 0xf8,
	0x60, 0x46, 0x04, 0x60, 0xf4, 0x36, 0xfa, 0x82, 0x83, 0x4d, 0x82, 0xcf, 0xc9, 0x84, 0xa4, 0x70,
	0xff, 0x6a, 0xff, 0x8d, 0xc0, 0x43, 0xc1, 0xe7, 0x64, 0x42, 0x4e, 0xac, 0x93, 0x09, 0xfb, 0x2c,
	0x3f, 0x3b, 0x46, 0x0d, 0x5b, 0x13, 0xa8, 0xcc, 0x46, 0xce, 0xcf, 0x2a, 0x45, 0x9a, 0x94, 0x9f,
	0x9d, 0x49, 0x0a, 0xe8, 0x2b, 0x0e, 0xb6, 0x5d, 0x32, 0xd6, 0xe9, 0x47, 0x58, 0x27, 0x2a, 0xb1,
	0x35, 0xfd, 0x25, 0x4d, 0x53, 0x1f, 0x9b, 0xb9, 0xe9, 0xd8, 0x48, 0x0c, 0x49, 0xf1, 0x80, 0x46,
	0xb0, 0x19, 0xa7, 0x80, 0x2c, 0x58, 0x75, 0xc9, 0xe0, 0x0e, 0x36, 0x89, 0x9f, 0xc2, 0x3c, 0xa3,
	0xf0, 0x8f, 0xa8, 0x14, 0x04, 0x6a, 0x1f, 0xf0, 0xbc, 0xd2, 0x19, 0x21, 0x47, 0xaf, 0x39, 0x58,
	0xd7, 0xda, 0x35, 0xc3, 0x52, 0x6d, 0xac, 0x5b, 0x75, 0xd3, 0x08, 0x5f, 0xc4, 0x15, 0xe6, 0xf7,
	0xdf, 0x51, 0x6a, 0x16, 0x85, 0x91, 0x07, 0x28, 0x01, 0xef, 0x19, 0x6d, 0xec, 0xee, 0x7e, 0x12,
	0x80, 0x95, 0x7a, 0x95, 0x74, 0x5b, 0x38, 0xfb, 0x31, 0x6c, 0x4c, 0x2c, 0x39, 0xe8, 0x39, 0x2c,
	0x85, 0x7a, 0xa8, 0x57, 0xcd, 0xee, 0x4e, 0x57, 0x58, 0x5b, 0x58, 0x97, 0x17, 0xb5, 0xc0, 0x3a,
	0x7b, 0x0b, 0xe6, 0xab, 0xd8, 0x26, 0xf8, 0x1c, 0x25, 0x81, 0x3b, 0x67, 0xb8, 0x73, 0x32, 0xc7,
	0x56, 0x5d, 0x56, 0xa7, 0xe6, 0x64, 0xae, 0x9b, 0xcd, 0x41, 0xaa, 0x64, 0xd9, 0x4d, 0xad, 0x61,
	0xbc, 0xc2, 0xb5, 0xb0, 0x3e, 0x1f, 0xd0, 0xe7, 0xa9, 0xfe, 0x09, 0x24, 0xfd, 0x55, 0x09, 0x09,
	0x10, 0xef, 0x60, 0x9b, 0x18, 0x3a, 0x76, 0xd2, 0xdc, 0x76, 0x6c, 0x27, 0xb1, 0x77, 0x27, 0xca,
	0xbd, 0x32, 0x47, 0x72, 0xdf, 0x34, 0xfb, 0x09, 0xac, 0x0e, 0x68, 0x04, 0x1c, 0xd4, 0x60, 0xd9,
	0xec, 0xef, 0xa8, 0x21, 0x5f, 0x51, 0x7a, 0x75, 0xf8, 0x78, 0x32, 0x32, 0x03, 0x12, 0xe6, 0xff,
	0x17, 0x1e, 0xd6, 0x26, 0x54, 0x64, 0x54, 0x85, 0xab, 0x81, 0x9a, 0xef, 0x15, 0xfa, 0x7c, 0x04,
	0xff, 0x7e, 0xc4, 0xa3, 0x19, 0x39, 0x79, 0xea, 0x3f, 0x5d, 0x1b, 0xd2, 0xbe, 0xd3, 0x05, 0x5d,
	0xb8, 0x25, 0xec, 0x9f, 0x53, 0x1d, 0x31, 0xe4, 0x6c, 0xd5, 0x1c, 0x1d, 0xd4, 0x4b, 0xcc, 0xbb,
	0xfd, 0x45, 0x70, 0x8f, 0x88, 0x6b, 0xaa, 0x66, 0x63, 0x2d, 0xfb, 0x04, 0xe2, 0xbd, 0x4e, 0xf2,
	0xae, 0xb2, 0xe5, 0x15, 0xa0, 0xc1, 0x91, 0xfb, 0xe0, 0xbf, 0x4f, 0xa6, 0x7c, 0xc7, 0xc3, 0xf5,
	0x31, 0x9d, 0x13, 0x89, 0x10, 0xef, 0xb5, 0x64, 0x2f, 0x41, 0xfe, 0x1a, 0xc1, 0x6d, 0x0f, 0xe8,
	0x68, 0x46, 0xee, 0x9b, 0xa3, 0x0f, 0x03, 0x87, 0xe9, 0xa3, 0xc6, 0x22, 0xcf, 0x77, 0xc3, 0x01,
	0x3a, 0x9a, 0xf1, 0x1f, 0xa8, 0x1f, 0xb6, 0xcb, 0xcc, 0x85, 0x79, 0x98, 0xa5, 0xd4, 0xb3, 0x3f,
	0xf7, 0xfe, 0x5e, 0x63, 0x1a, 0xfa, 0x6b, 0x2e, 0x30, 0x8f, 0xeb, 0x56, 0xc3, 0xb2, 0x7b, 0x37,
	0xa7, 0xbc, 0xdd, 0x2c, 0xe1, 0xa3, 0x58, 0x64, 0xb0, 0x82, 0x49, 0xec, 0xae, 0x7f, 0x60, 0x77,
	0xc5, 0x68, 0x0d, 0x16, 0x9a, 0x46, 0xd3, 0xad, 0xdc, 0xec, 0xf6, 0x16, 0xe4, 0x38, 0x15, 0x28,
	0xdd, 0x16, 0x46, 0x5b, 0x90, 0xf0, 0x26, 0xbf, 0x2e, 0xc1, 0x0e, 0xbb, 0x86, 0xa4, 0x0c, 0xee,
	0x90, 0x46, 0x25, 0x99, 0x0e, 0xfc, 0x69, 0xa4, 0x23, 0x94, 0x82, 0xd8, 0x4b, 0xdc, 0xf5, 0x1e,
	0x1f, 0xf4, 0x27, 0x3a, 0x84, 0x39, 0xf7, 0x39, 0xc0, 0xff, 0xd6, 0x30, 0xbb, 0xf6, 0x0f, 0xf8,
	0xfb, 0x5c, 0xf6, 0x15, 0xac, 0x4f, 0x1a, 0x60, 0x2e, 0xb5, 0xc3, 0x7c, 0xc3, 0x41, 0x42, 0x31,
	0x9a, 0xbd, 0xc0, 0x23, 0x01, 0xae, 0x39, 0x44, 0xb3, 0x89, 0x4a, 0x07, 0x7a, 0xd5, 0x3a, 0x3b,
	0x73, 0x30, 0xf1, 0xbc, 0xdd, 0xe8, 0x79, 0xeb, 0x3d, 0xe9, 0x72, 0x07, 0xde, 0x83, 0x50, 0x5e,
	0x62, 0x36, 0x14, 0x47, 0x62, 0x16, 0xa8, 0x00, 0x4b, 0xd8, 0xac, 0x05, 0x40, 0xf8, 0x8b, 0x40,
	0xae, 0x62, 0xb3, 0x36, 0x80, 0xc8, 0xfe, 0xc8, 0xc1, 0xc6, 0xc4, 0x61, 0x0a, 0x3d, 0x81, 0x24,
	0x73, 0xe0, 0xcd, 0xb1, 0x1e, 0xcd, 0x5c, 0x94, 0x79, 0x71, 0x70, 0x62, 0x39, 0x41, 0x7c, 0xc7,
	0x1f, 0x11, 0x6a, 0xfe, 0x5d, 0x85, 0xfa, 0x5b, 0x1e, 0x96, 0x83, 0x93, 0xd6, 0x23, 0x9b, 0xbe,
	0x63, 0x87, 0xfa, 0x12, 0x77, 0xf9, 0x7d, 0x89, 0xbf, 0xbc, 0xbe, 0xf4, 0x00, 0x12, 0xfe, 0x6b,
	0x8f, 0x5d, 0x74, 0xed, 0x40, 0xfa, 0x77, 0x3e, 0xd4, 0x77, 0xbe, 0xe7, 0xbd, 0x1c, 0x18, 0x3b,
	0xa1, 0x5e, 0xe2, 0x7f, 0x63, 0x28, 0xbf, 0xf8, 0xb7, 0xcf, 0xaf, 0x06, 0xac, 0x86, 0xe7, 0xfa,
	0x33, 0x9a, 0x04, 0xb4, 0x1c, 0xd1, 0x42, 0x19, 0xe5, 0x31, 0x3e, 0x22, 0x87, 0xe4, 0x15, 0x6b,
	0x58, 0xe8, 0x64, 0x7f, 0xe0, 0x60, 0x65, 0xd4, 0xf8, 0xfd, 0x07, 0x8b, 0x5a, 0xf6, 0x0d, 0x07,
	0x99, 0xf1, 0xe3, 0x3c, 0xda, 0x04, 0x20, 0xb6, 0x66, 0x3a, 0xba, 0x6d, 0xb4, 0x88, 0x57, 0xa5,
	0x7d, 0x12, 0xf4, 0x2f, 0x48, 0xba, 0x35, 0x2d, 0x6a, 0x25, 0x4a, 0x30, 0x75, 0xaf, 0x94, 0xdd,
	0x07, 0xa0, 0xa5, 0x2c, 0x6a, 0x3a, 0x2f, 0x60, 0xb3, 0xe6, 0x55, 0xb0, 0x0e, 0xa0, 0xe1, 0x2f,
	0x34, 0xe8, 0x05, 0x5c, 0xb3, 0x5a, 0xd8, 0xd6, 0x88, 0x65, 0x0f, 0xbe, 0xf9, 0xb8, 0x94, 0xa2,
	0x0c, 0x38, 0x92, 0x67, 0xdb, 0xff, 0xe2, 0x93, 0xb2, 0x42, 0x92, 0xec, 0xe7, 0x1c, 0xa4, 0xc2,
	0x6a, 0x68, 0x05, 0xe6, 0x1c, 0xdd, 0xb2, 0xb1, 0xf7, 0x28, 0x70, 0x17, 0xb4, 0x27, 0x12, 0x8b,
	0x68, 0x0d, 0xb5, 0x63, 0xd1, 0x9e, 0xe8, 0x3e, 0x29, 0x80, 0x89, 0xaa, 0x54, 0x42, 0x15, 0x18,
	0x05, 0x4f, 0x21, 0xe6, 0x2a, 0x30, 0x91, 0xab, 0x90, 0x81, 0xb8, 0x6e, 0x35, 0xe9, 0x35, 0x39,
	0xe9, 0xd9, 0xed, 0x18, 0xed, 0xb8, 0xbd, 0xf5, 0x6e, 0x11, 0x52, 0xe1, 0xaf, 0x6c, 0xe8, 0x26,
	0x6c, 0x14, 0x4a, 0x25, 0x49, 0x29, 0x28, 0xa2, 0x54, 0x52, 0x2b, 0xd2, 0x89, 0x5c, 0x14, 0xd4,
	0x93, 0x52, 0xa5, 0x2c, 0x14, 0xc5, 0x47, 0xa2, 0x70, 0x90, 0x9a, 0x41, 0x49, 0x88, 0x4b, 0x65,
	0x41, 0x2e, 0x28, 0x92, 0x9c, 0x8a, 0xed, 0xbe, 0x0f, 0xcb, 0x23, 0x3e, 0x3f, 0xa1, 0x5b, 0xb0,
	0xed, 0xc7, 0x11, 0x4a, 0x8a, 0x78, 0x2c, 0x94, 0x94, 0x61, 0xa8, 0x92, 0x70, 0x58, 0x50, 0xc4,
	0xaa, 0x90, 0xe2, 0xe8, 0xaa, 0x2c, 0x55, 0x44, 0xb6, 0xe2, 0x77, 0xbf, 0x9e, 0x85, 0xc5, 0x01,
	0xb2, 0x37, 0x22, 0xac, 0xf9, 0x40, 0x95, 0x67, 0xe5, 0x30, 0xb5, 0x3f, 0xc3, 0x96, 0x78, 0x5c,
	0x38, 0x14, 0xd4, 0xe2, 0xe3, 0x42, 0xa5, 0x22, 0x3e, 0x12, 0x8b, 0xae, 0xea, 0xc0, 0x2a, 0xc5,
	0xd1, 0x23, 0xba, 0x4a, 0xfb, 0xd2, 0x49, 0xe9, 0x40, 0x2c, 0x1d, 0xaa, 0xfb, 0xd2, 0x53, 0xbf,
	0x0a, 0x8f, 0x76, 0xe1, 0x2f, 0xae, 0x8a, 0x24, 0x8b, 0x42, 0x49, 0x11, 0x0e, 0xc6, 0xea, 0x5e,
	0x45, 0x59, 0xd8, 0x0c, 0xc1, 0x95, 0xa5, 0xc7, 0xcf, 0xfc, 0x3a, 0x80, 0x36, 0xe0, 0x86, 0xab,
	0x43, 0xb7, 0x1e, 0x8b, 0x25, 0xc1, 0xbf, 0x9d, 0x18, 0x30, 0xaa, 0x08, 0x87, 0x34, 0x4a, 0x43,
	0xa4, 0x93, 0xe8, 0x0e, 0xdc, 0xae, 0x8a, 0x07, 0x82, 0xa4, 0x56, 0x8e, 0x24, 0xa5, 0x32, 0xe1,
	0x7c, 0x31, 0x1a, 0x7a, 0x57, 0x55, 0xda, 0xff, 0xbf, 0x50, 0x54, 0x54, 0x45, 0x2e, 0x14, 0xdf,
	0xa3, 0xbc, 0x7c, 0x5a, 0xb3, 0xe8, 0x36, 0xdc, 0x0c, 0x68, 0x1d, 0x08, 0x8a, 0x50, 0x0c, 0x83,
	0xcd, 0xa1, 0x0c, 0xac, 0xba, 0x6a, 0x42, 0x95, 0x5e, 0x9f, 0x6f, 0x6f, 0x9e, 0x9e, 0xbc, 0x70,
	0x72, 0x20, 0x4a, 0xd4, 0x43, 0xa9, 0x52, 0x94, 0xc5, 0x72, 0xd8, 0xfe, 0x0a, 0xd5, 0x51, 0x84,
	0xa7, 0xca, 0x04, 0xc2, 0x71, 0x4a, 0x85, 0xe9, 0xd0, 0x24, 0x51, 0x9e, 0xa9, 0xc2, 0x53, 0xca,
	0x38, 0xac, 0xb6, 0xb0, 0x7f, 0x0e, 0xb7, 0x75, 0xab, 0x79, 0xf1, 0x7f, 0xb0, 0xcc, 0x3d, 0x3f,
	0xf6, 0x94, 0xea, 0x56, 0x43, 0x33, 0xeb, 0x39, 0xcb, 0xae, 0xe7, 0xeb, 0xd8, 0x64, 0xd5, 0x20,
	0xef, 0x6e, 0x69, 0x2d, 0xc3, 0x99, 0xf0, 0xdd, 0xfd, 0xa1, 0x5f, 0x78, 0x3a, 0xcf, 0x2c, 0xef,
	0xfd, 0x1a, 0x00, 0x00, 0xff, 0xff, 0x98, 0xce, 0x14, 0xed, 0x07, 0x18, 0x00, 0x00,
}
