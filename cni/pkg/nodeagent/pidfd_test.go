// Copyright Istio Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package nodeagent

import (
	"os"
	"runtime"
	"testing"
)

func TestPidFdOpen(t *testing.T) {
	if runtime.GOOS != "linux" {
		// pidfd open is only supported on Linux 5.3+, so skip the test on other platforms
		// if this is a new architure, we just need to add the syscall number in pidfd_linux_$arch.go and the test will run without modification
		t.Skip("pidfd open is not supported on this platform")
	}
	pid := os.Getpid()
	pidfd, err := PidFdOpen(pid)
	if err != nil {
		t.Fatalf("pidfd open failed for pid %d: %v", pid, err)
	}
	defer pidfd.Close()

	if !pidfd.IsValid() {
		t.Fatalf("pidfd is not valid for pid %d", pid)
	}

	if pidFromFd, err := pidfd.Pid(); err != nil {
		t.Fatalf("process with PID %d was replaced during processing", pid)
	} else if pidFromFd != pid {
		t.Fatalf("process with PID %d was replaced during processing", pid)
	}
}

func TestParsePidFromFdInfo(t *testing.T) {
	// This format is based on the output of /proc/self/fdinfo/<pidfd> on Linux. It is generated by pidfd_show_fdinfo in fs/pidfs.c
	tests := []struct {
		name    string
		input   []byte
		want    int
		wantErr string
	}{
		{
			name: "valid pid",
			input: []byte(`pos:	0
flags:	02000000
mnt_id:	12
ino:	1234
Pid:	12345
NSpid:	12346
`),
			want:    12345,
			wantErr: "",
		},
		{
			name: "valid pid with extra fields",
			input: []byte(`pos:	0
flags:	02000000
mnt_id:	12
ino:	1234
Pid:	999
NSpid:	1000
other:	field
`),
			want:    999,
			wantErr: "",
		},
		{
			name: "pid is zero",
			input: []byte(`pos:	0
flags:	02000000
Pid:	0
NSpid:	0
`),
			want:    0,
			wantErr: "pid is zero - process likely not available in pidns",
		},
		{
			name: "negative pid",
			input: []byte(`pos:	0
flags:	02000000
Pid:	-1
NSpid:	-1
`),
			want:    0,
			wantErr: "invalid pid - process likely gone",
		},
		{
			name: "pid not found",
			input: []byte(`pos:	0
flags:	02000000
mnt_id:	12
ino:	1234
`),
			want:    0,
			wantErr: "pid not found in fdinfo",
		},
		{
			name:    "empty input",
			input:   []byte(""),
			want:    0,
			wantErr: "pid not found in fdinfo",
		},
		{
			name: "single digit pid",
			input: []byte(`Pid:	1
`),
			want:    1,
			wantErr: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := parsePidFromFdInfo(tt.input)
			if tt.wantErr != "" {
				if err == nil {
					t.Errorf("parsePidFromFdInfo() expected error containing %q, got nil", tt.wantErr)
					return
				}
				if err.Error() != tt.wantErr && !contains(err.Error(), tt.wantErr) {
					t.Errorf("parsePidFromFdInfo() error = %v, want error containing %q", err, tt.wantErr)
				}
				return
			}
			if err != nil {
				t.Errorf("parsePidFromFdInfo() unexpected error = %v", err)
				return
			}
			if got != tt.want {
				t.Errorf("parsePidFromFdInfo() = %v, want %v", got, tt.want)
			}
		})
	}
}

func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(s) > len(substr) && findSubstring(s, substr))
}

func findSubstring(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}
