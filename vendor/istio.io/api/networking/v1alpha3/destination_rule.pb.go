// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: networking/v1alpha3/destination_rule.proto

/*
	Package v1alpha3 is a generated protocol buffer package.

	It is generated from these files:
		networking/v1alpha3/destination_rule.proto
		networking/v1alpha3/envoy_filter.proto
		networking/v1alpha3/gateway.proto
		networking/v1alpha3/service_entry.proto
		networking/v1alpha3/sidecar.proto
		networking/v1alpha3/virtual_service.proto

	It has these top-level messages:
		DestinationRule
		TrafficPolicy
		Subset
		LoadBalancerSettings
		ConnectionPoolSettings
		OutlierDetection
		TLSSettings
		EnvoyFilter
		Gateway
		Server
		Port
		ServiceEntry
		Sidecar
		IstioIngressListener
		IstioEgressListener
		WorkloadSelector
		VirtualService
		Destination
		HTTPRoute
		Headers
		TLSRoute
		TCPRoute
		HTTPMatchRequest
		HTTPRouteDestination
		RouteDestination
		L4MatchAttributes
		TLSMatchAttributes
		HTTPRedirect
		HTTPRewrite
		StringMatch
		HTTPRetry
		CorsPolicy
		HTTPFaultInjection
		PortSelector
		Percent
*/
package v1alpha3

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/gogo/protobuf/types"
import _ "github.com/gogo/protobuf/gogoproto"

import time "time"

import types "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Standard load balancing algorithms that require no tuning.
type LoadBalancerSettings_SimpleLB int32

const (
	// Round Robin policy. Default
	LoadBalancerSettings_ROUND_ROBIN LoadBalancerSettings_SimpleLB = 0
	// The least request load balancer uses an O(1) algorithm which selects
	// two random healthy hosts and picks the host which has fewer active
	// requests.
	LoadBalancerSettings_LEAST_CONN LoadBalancerSettings_SimpleLB = 1
	// The random load balancer selects a random healthy host. The random
	// load balancer generally performs better than round robin if no health
	// checking policy is configured.
	LoadBalancerSettings_RANDOM LoadBalancerSettings_SimpleLB = 2
	// This option will forward the connection to the original IP address
	// requested by the caller without doing any form of load
	// balancing. This option must be used with care. It is meant for
	// advanced use cases. Refer to Original Destination load balancer in
	// Envoy for further details.
	LoadBalancerSettings_PASSTHROUGH LoadBalancerSettings_SimpleLB = 3
)

var LoadBalancerSettings_SimpleLB_name = map[int32]string{
	0: "ROUND_ROBIN",
	1: "LEAST_CONN",
	2: "RANDOM",
	3: "PASSTHROUGH",
}
var LoadBalancerSettings_SimpleLB_value = map[string]int32{
	"ROUND_ROBIN": 0,
	"LEAST_CONN":  1,
	"RANDOM":      2,
	"PASSTHROUGH": 3,
}

func (x LoadBalancerSettings_SimpleLB) String() string {
	return proto.EnumName(LoadBalancerSettings_SimpleLB_name, int32(x))
}
func (LoadBalancerSettings_SimpleLB) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorDestinationRule, []int{3, 0}
}

// TLS connection mode
type TLSSettings_TLSmode int32

const (
	// Do not setup a TLS connection to the upstream endpoint.
	TLSSettings_DISABLE TLSSettings_TLSmode = 0
	// Originate a TLS connection to the upstream endpoint.
	TLSSettings_SIMPLE TLSSettings_TLSmode = 1
	// Secure connections to the upstream using mutual TLS by presenting
	// client certificates for authentication.
	TLSSettings_MUTUAL TLSSettings_TLSmode = 2
	// Secure connections to the upstream using mutual TLS by presenting
	// client certificates for authentication.
	// Compared to Mutual mode, this mode uses certificates generated
	// automatically by Istio for mTLS authentication. When this mode is
	// used, all other fields in `TLSSettings` should be empty.
	TLSSettings_ISTIO_MUTUAL TLSSettings_TLSmode = 3
)

var TLSSettings_TLSmode_name = map[int32]string{
	0: "DISABLE",
	1: "SIMPLE",
	2: "MUTUAL",
	3: "ISTIO_MUTUAL",
}
var TLSSettings_TLSmode_value = map[string]int32{
	"DISABLE":      0,
	"SIMPLE":       1,
	"MUTUAL":       2,
	"ISTIO_MUTUAL": 3,
}

func (x TLSSettings_TLSmode) String() string {
	return proto.EnumName(TLSSettings_TLSmode_name, int32(x))
}
func (TLSSettings_TLSmode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorDestinationRule, []int{6, 0}
}

// `DestinationRule` defines policies that apply to traffic intended for a
// service after routing has occurred. These rules specify configuration
// for load balancing, connection pool size from the sidecar, and outlier
// detection settings to detect and evict unhealthy hosts from the load
// balancing pool. For example, a simple load balancing policy for the
// ratings service would look as follows:
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: DestinationRule
// metadata:
//   name: bookinfo-ratings
// spec:
//   host: ratings.prod.svc.cluster.local
//   trafficPolicy:
//     loadBalancer:
//       simple: LEAST_CONN
// ```
//
// Version specific policies can be specified by defining a named
// `subset` and overriding the settings specified at the service level. The
// following rule uses a round robin load balancing policy for all traffic
// going to a subset named testversion that is composed of endpoints (e.g.,
// pods) with labels (version:v3).
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: DestinationRule
// metadata:
//   name: bookinfo-ratings
// spec:
//   host: ratings.prod.svc.cluster.local
//   trafficPolicy:
//     loadBalancer:
//       simple: LEAST_CONN
//   subsets:
//   - name: testversion
//     labels:
//       version: v3
//     trafficPolicy:
//       loadBalancer:
//         simple: ROUND_ROBIN
// ```
//
// **Note:** Policies specified for subsets will not take effect until
// a route rule explicitly sends traffic to this subset.
//
// Traffic policies can be customized to specific ports as well. The
// following rule uses the least connection load balancing policy for all
// traffic to port 80, while uses a round robin load balancing setting for
// traffic to the port 9080.
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: DestinationRule
// metadata:
//   name: bookinfo-ratings-port
// spec:
//   host: ratings.prod.svc.cluster.local
//   trafficPolicy: # Apply to all ports
//     portLevelSettings:
//     - port:
//         number: 80
//       loadBalancer:
//         simple: LEAST_CONN
//     - port:
//         number: 9080
//       loadBalancer:
//         simple: ROUND_ROBIN
// ```
type DestinationRule struct {
	// REQUIRED. The name of a service from the service registry. Service
	// names are looked up from the platform's service registry (e.g.,
	// Kubernetes services, Consul services, etc.) and from the hosts
	// declared by [ServiceEntries](#ServiceEntry). Rules defined for
	// services that do not exist in the service registry will be ignored.
	//
	// *Note for Kubernetes users*: When short names are used (e.g. "reviews"
	// instead of "reviews.default.svc.cluster.local"), Istio will interpret
	// the short name based on the namespace of the rule, not the service. A
	// rule in the "default" namespace containing a host "reviews will be
	// interpreted as "reviews.default.svc.cluster.local", irrespective of
	// the actual namespace associated with the reviews service. _To avoid
	// potential misconfigurations, it is recommended to always use fully
	// qualified domain names over short names._
	//
	// Note that the host field applies to both HTTP and TCP services.
	Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	// Traffic policies to apply (load balancing policy, connection pool
	// sizes, outlier detection).
	TrafficPolicy *TrafficPolicy `protobuf:"bytes,2,opt,name=traffic_policy,json=trafficPolicy" json:"traffic_policy,omitempty"`
	// One or more named sets that represent individual versions of a
	// service. Traffic policies can be overridden at subset level.
	Subsets []*Subset `protobuf:"bytes,3,rep,name=subsets" json:"subsets,omitempty"`
	// The visibility setting associated with this DestinationRule. Set to
	// PRIVATE if this destination rule should not be exported, i.e. restrict
	// the applicability of this destination rule to only workloads in the same
	// namespace as the destination rule.
	ConfigScope ConfigScope `protobuf:"varint,4,opt,name=config_scope,json=configScope,proto3,enum=istio.networking.v1alpha3.ConfigScope" json:"config_scope,omitempty"`
}

func (m *DestinationRule) Reset()                    { *m = DestinationRule{} }
func (m *DestinationRule) String() string            { return proto.CompactTextString(m) }
func (*DestinationRule) ProtoMessage()               {}
func (*DestinationRule) Descriptor() ([]byte, []int) { return fileDescriptorDestinationRule, []int{0} }

func (m *DestinationRule) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *DestinationRule) GetTrafficPolicy() *TrafficPolicy {
	if m != nil {
		return m.TrafficPolicy
	}
	return nil
}

func (m *DestinationRule) GetSubsets() []*Subset {
	if m != nil {
		return m.Subsets
	}
	return nil
}

func (m *DestinationRule) GetConfigScope() ConfigScope {
	if m != nil {
		return m.ConfigScope
	}
	return ConfigScope_PUBLIC
}

// Traffic policies to apply for a specific destination, across all
// destination ports. See DestinationRule for examples.
type TrafficPolicy struct {
	// Settings controlling the load balancer algorithms.
	LoadBalancer *LoadBalancerSettings `protobuf:"bytes,1,opt,name=load_balancer,json=loadBalancer" json:"load_balancer,omitempty"`
	// Settings controlling the volume of connections to an upstream service
	ConnectionPool *ConnectionPoolSettings `protobuf:"bytes,2,opt,name=connection_pool,json=connectionPool" json:"connection_pool,omitempty"`
	// Settings controlling eviction of unhealthy hosts from the load balancing pool
	OutlierDetection *OutlierDetection `protobuf:"bytes,3,opt,name=outlier_detection,json=outlierDetection" json:"outlier_detection,omitempty"`
	// TLS related settings for connections to the upstream service.
	Tls *TLSSettings `protobuf:"bytes,4,opt,name=tls" json:"tls,omitempty"`
	// Traffic policies specific to individual ports. Note that port level
	// settings will override the destination-level settings. Traffic
	// settings specified at the destination-level will not be inherited when
	// overridden by port-level settings, i.e. default values will be applied
	// to fields omitted in port-level traffic policies.
	PortLevelSettings []*TrafficPolicy_PortTrafficPolicy `protobuf:"bytes,5,rep,name=port_level_settings,json=portLevelSettings" json:"port_level_settings,omitempty"`
}

func (m *TrafficPolicy) Reset()                    { *m = TrafficPolicy{} }
func (m *TrafficPolicy) String() string            { return proto.CompactTextString(m) }
func (*TrafficPolicy) ProtoMessage()               {}
func (*TrafficPolicy) Descriptor() ([]byte, []int) { return fileDescriptorDestinationRule, []int{1} }

func (m *TrafficPolicy) GetLoadBalancer() *LoadBalancerSettings {
	if m != nil {
		return m.LoadBalancer
	}
	return nil
}

func (m *TrafficPolicy) GetConnectionPool() *ConnectionPoolSettings {
	if m != nil {
		return m.ConnectionPool
	}
	return nil
}

func (m *TrafficPolicy) GetOutlierDetection() *OutlierDetection {
	if m != nil {
		return m.OutlierDetection
	}
	return nil
}

func (m *TrafficPolicy) GetTls() *TLSSettings {
	if m != nil {
		return m.Tls
	}
	return nil
}

func (m *TrafficPolicy) GetPortLevelSettings() []*TrafficPolicy_PortTrafficPolicy {
	if m != nil {
		return m.PortLevelSettings
	}
	return nil
}

// Traffic policies that apply to specific ports of the service
type TrafficPolicy_PortTrafficPolicy struct {
	// Specifies the port name or number of a port on the destination service
	// on which this policy is being applied.
	//
	// Names must comply with DNS label syntax (rfc1035) and therefore cannot
	// collide with numbers. If there are multiple ports on a service with
	// the same protocol the names should be of the form <protocol-name>-<DNS
	// label>.
	Port *PortSelector `protobuf:"bytes,1,opt,name=port" json:"port,omitempty"`
	// Settings controlling the load balancer algorithms.
	LoadBalancer *LoadBalancerSettings `protobuf:"bytes,2,opt,name=load_balancer,json=loadBalancer" json:"load_balancer,omitempty"`
	// Settings controlling the volume of connections to an upstream service
	ConnectionPool *ConnectionPoolSettings `protobuf:"bytes,3,opt,name=connection_pool,json=connectionPool" json:"connection_pool,omitempty"`
	// Settings controlling eviction of unhealthy hosts from the load balancing pool
	OutlierDetection *OutlierDetection `protobuf:"bytes,4,opt,name=outlier_detection,json=outlierDetection" json:"outlier_detection,omitempty"`
	// TLS related settings for connections to the upstream service.
	Tls *TLSSettings `protobuf:"bytes,5,opt,name=tls" json:"tls,omitempty"`
}

func (m *TrafficPolicy_PortTrafficPolicy) Reset()         { *m = TrafficPolicy_PortTrafficPolicy{} }
func (m *TrafficPolicy_PortTrafficPolicy) String() string { return proto.CompactTextString(m) }
func (*TrafficPolicy_PortTrafficPolicy) ProtoMessage()    {}
func (*TrafficPolicy_PortTrafficPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptorDestinationRule, []int{1, 0}
}

func (m *TrafficPolicy_PortTrafficPolicy) GetPort() *PortSelector {
	if m != nil {
		return m.Port
	}
	return nil
}

func (m *TrafficPolicy_PortTrafficPolicy) GetLoadBalancer() *LoadBalancerSettings {
	if m != nil {
		return m.LoadBalancer
	}
	return nil
}

func (m *TrafficPolicy_PortTrafficPolicy) GetConnectionPool() *ConnectionPoolSettings {
	if m != nil {
		return m.ConnectionPool
	}
	return nil
}

func (m *TrafficPolicy_PortTrafficPolicy) GetOutlierDetection() *OutlierDetection {
	if m != nil {
		return m.OutlierDetection
	}
	return nil
}

func (m *TrafficPolicy_PortTrafficPolicy) GetTls() *TLSSettings {
	if m != nil {
		return m.Tls
	}
	return nil
}

// A subset of endpoints of a service. Subsets can be used for scenarios
// like A/B testing, or routing to a specific version of a service. Refer
// to [VirtualService](#VirtualService) documentation for examples of using
// subsets in these scenarios. In addition, traffic policies defined at the
// service-level can be overridden at a subset-level. The following rule
// uses a round robin load balancing policy for all traffic going to a
// subset named testversion that is composed of endpoints (e.g., pods) with
// labels (version:v3).
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: DestinationRule
// metadata:
//   name: bookinfo-ratings
// spec:
//   host: ratings.prod.svc.cluster.local
//   trafficPolicy:
//     loadBalancer:
//       simple: LEAST_CONN
//   subsets:
//   - name: testversion
//     labels:
//       version: v3
//     trafficPolicy:
//       loadBalancer:
//         simple: ROUND_ROBIN
// ```
//
// **Note:** Policies specified for subsets will not take effect until
// a route rule explicitly sends traffic to this subset.
//
// One or more labels are typically required to identify the subset destination,
// however, when the corresponding DestinationRule represents a host that
// supports multiple SNI hosts (e.g., an egress gateway), a subset without labels
// may be meaningful. In this case a traffic policy with [TLSSettings](#TLSSettings)
// can be used to identify a specific SNI host corresponding to the named subset.
type Subset struct {
	// REQUIRED. Name of the subset. The service name and the subset name can
	// be used for traffic splitting in a route rule.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Labels apply a filter over the endpoints of a service in the
	// service registry. See route rules for examples of usage.
	Labels map[string]string `protobuf:"bytes,2,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Traffic policies that apply to this subset. Subsets inherit the
	// traffic policies specified at the DestinationRule level. Settings
	// specified at the subset level will override the corresponding settings
	// specified at the DestinationRule level.
	TrafficPolicy *TrafficPolicy `protobuf:"bytes,3,opt,name=traffic_policy,json=trafficPolicy" json:"traffic_policy,omitempty"`
}

func (m *Subset) Reset()                    { *m = Subset{} }
func (m *Subset) String() string            { return proto.CompactTextString(m) }
func (*Subset) ProtoMessage()               {}
func (*Subset) Descriptor() ([]byte, []int) { return fileDescriptorDestinationRule, []int{2} }

func (m *Subset) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Subset) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Subset) GetTrafficPolicy() *TrafficPolicy {
	if m != nil {
		return m.TrafficPolicy
	}
	return nil
}

// Load balancing policies to apply for a specific destination. See Envoy's
// load balancing
// [documentation](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/load_balancing/load_balancing)
// for more details.
//
// For example, the following rule uses a round robin load balancing policy
// for all traffic going to the ratings service.
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: DestinationRule
// metadata:
//   name: bookinfo-ratings
// spec:
//   host: ratings.prod.svc.cluster.local
//   trafficPolicy:
//     loadBalancer:
//       simple: ROUND_ROBIN
// ```
//
// The following example sets up sticky sessions for the ratings service
// hashing-based load balancer for the same ratings service using the
// the User cookie as the hash key.
//
// ```yaml
//  apiVersion: networking.istio.io/v1alpha3
//  kind: DestinationRule
//  metadata:
//    name: bookinfo-ratings
//  spec:
//    host: ratings.prod.svc.cluster.local
//    trafficPolicy:
//      loadBalancer:
//        consistentHash:
//          httpCookie:
//            name: user
//            ttl: 0s
// ```
//
type LoadBalancerSettings struct {
	// Upstream load balancing policy.
	//
	// Types that are valid to be assigned to LbPolicy:
	//	*LoadBalancerSettings_Simple
	//	*LoadBalancerSettings_ConsistentHash
	LbPolicy isLoadBalancerSettings_LbPolicy `protobuf_oneof:"lb_policy"`
}

func (m *LoadBalancerSettings) Reset()         { *m = LoadBalancerSettings{} }
func (m *LoadBalancerSettings) String() string { return proto.CompactTextString(m) }
func (*LoadBalancerSettings) ProtoMessage()    {}
func (*LoadBalancerSettings) Descriptor() ([]byte, []int) {
	return fileDescriptorDestinationRule, []int{3}
}

type isLoadBalancerSettings_LbPolicy interface {
	isLoadBalancerSettings_LbPolicy()
	MarshalTo([]byte) (int, error)
	Size() int
}

type LoadBalancerSettings_Simple struct {
	Simple LoadBalancerSettings_SimpleLB `protobuf:"varint,1,opt,name=simple,proto3,enum=istio.networking.v1alpha3.LoadBalancerSettings_SimpleLB,oneof"`
}
type LoadBalancerSettings_ConsistentHash struct {
	ConsistentHash *LoadBalancerSettings_ConsistentHashLB `protobuf:"bytes,2,opt,name=consistent_hash,json=consistentHash,oneof"`
}

func (*LoadBalancerSettings_Simple) isLoadBalancerSettings_LbPolicy()         {}
func (*LoadBalancerSettings_ConsistentHash) isLoadBalancerSettings_LbPolicy() {}

func (m *LoadBalancerSettings) GetLbPolicy() isLoadBalancerSettings_LbPolicy {
	if m != nil {
		return m.LbPolicy
	}
	return nil
}

func (m *LoadBalancerSettings) GetSimple() LoadBalancerSettings_SimpleLB {
	if x, ok := m.GetLbPolicy().(*LoadBalancerSettings_Simple); ok {
		return x.Simple
	}
	return LoadBalancerSettings_ROUND_ROBIN
}

func (m *LoadBalancerSettings) GetConsistentHash() *LoadBalancerSettings_ConsistentHashLB {
	if x, ok := m.GetLbPolicy().(*LoadBalancerSettings_ConsistentHash); ok {
		return x.ConsistentHash
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LoadBalancerSettings) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LoadBalancerSettings_OneofMarshaler, _LoadBalancerSettings_OneofUnmarshaler, _LoadBalancerSettings_OneofSizer, []interface{}{
		(*LoadBalancerSettings_Simple)(nil),
		(*LoadBalancerSettings_ConsistentHash)(nil),
	}
}

func _LoadBalancerSettings_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LoadBalancerSettings)
	// lb_policy
	switch x := m.LbPolicy.(type) {
	case *LoadBalancerSettings_Simple:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Simple))
	case *LoadBalancerSettings_ConsistentHash:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ConsistentHash); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("LoadBalancerSettings.LbPolicy has unexpected type %T", x)
	}
	return nil
}

func _LoadBalancerSettings_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LoadBalancerSettings)
	switch tag {
	case 1: // lb_policy.simple
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.LbPolicy = &LoadBalancerSettings_Simple{LoadBalancerSettings_SimpleLB(x)}
		return true, err
	case 2: // lb_policy.consistent_hash
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoadBalancerSettings_ConsistentHashLB)
		err := b.DecodeMessage(msg)
		m.LbPolicy = &LoadBalancerSettings_ConsistentHash{msg}
		return true, err
	default:
		return false, nil
	}
}

func _LoadBalancerSettings_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LoadBalancerSettings)
	// lb_policy
	switch x := m.LbPolicy.(type) {
	case *LoadBalancerSettings_Simple:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Simple))
	case *LoadBalancerSettings_ConsistentHash:
		s := proto.Size(x.ConsistentHash)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Consistent Hash-based load balancing can be used to provide soft
// session affinity based on HTTP headers, cookies or other
// properties. This load balancing policy is applicable only for HTTP
// connections. The affinity to a particular destination host will be
// lost when one or more hosts are added/removed from the destination
// service.
type LoadBalancerSettings_ConsistentHashLB struct {
	// REQUIRED: The hash key to use.
	//
	// Types that are valid to be assigned to HashKey:
	//	*LoadBalancerSettings_ConsistentHashLB_HttpHeaderName
	//	*LoadBalancerSettings_ConsistentHashLB_HttpCookie
	//	*LoadBalancerSettings_ConsistentHashLB_UseSourceIp
	HashKey isLoadBalancerSettings_ConsistentHashLB_HashKey `protobuf_oneof:"hash_key"`
	// The minimum number of virtual nodes to use for the hash
	// ring. Defaults to 1024. Larger ring sizes result in more granular
	// load distributions. If the number of hosts in the load balancing
	// pool is larger than the ring size, each host will be assigned a
	// single virtual node.
	MinimumRingSize uint64 `protobuf:"varint,4,opt,name=minimum_ring_size,json=minimumRingSize,proto3" json:"minimum_ring_size,omitempty"`
}

func (m *LoadBalancerSettings_ConsistentHashLB) Reset()         { *m = LoadBalancerSettings_ConsistentHashLB{} }
func (m *LoadBalancerSettings_ConsistentHashLB) String() string { return proto.CompactTextString(m) }
func (*LoadBalancerSettings_ConsistentHashLB) ProtoMessage()    {}
func (*LoadBalancerSettings_ConsistentHashLB) Descriptor() ([]byte, []int) {
	return fileDescriptorDestinationRule, []int{3, 0}
}

type isLoadBalancerSettings_ConsistentHashLB_HashKey interface {
	isLoadBalancerSettings_ConsistentHashLB_HashKey()
	MarshalTo([]byte) (int, error)
	Size() int
}

type LoadBalancerSettings_ConsistentHashLB_HttpHeaderName struct {
	HttpHeaderName string `protobuf:"bytes,1,opt,name=http_header_name,json=httpHeaderName,proto3,oneof"`
}
type LoadBalancerSettings_ConsistentHashLB_HttpCookie struct {
	HttpCookie *LoadBalancerSettings_ConsistentHashLB_HTTPCookie `protobuf:"bytes,2,opt,name=http_cookie,json=httpCookie,oneof"`
}
type LoadBalancerSettings_ConsistentHashLB_UseSourceIp struct {
	UseSourceIp bool `protobuf:"varint,3,opt,name=use_source_ip,json=useSourceIp,proto3,oneof"`
}

func (*LoadBalancerSettings_ConsistentHashLB_HttpHeaderName) isLoadBalancerSettings_ConsistentHashLB_HashKey() {
}
func (*LoadBalancerSettings_ConsistentHashLB_HttpCookie) isLoadBalancerSettings_ConsistentHashLB_HashKey() {
}
func (*LoadBalancerSettings_ConsistentHashLB_UseSourceIp) isLoadBalancerSettings_ConsistentHashLB_HashKey() {
}

func (m *LoadBalancerSettings_ConsistentHashLB) GetHashKey() isLoadBalancerSettings_ConsistentHashLB_HashKey {
	if m != nil {
		return m.HashKey
	}
	return nil
}

func (m *LoadBalancerSettings_ConsistentHashLB) GetHttpHeaderName() string {
	if x, ok := m.GetHashKey().(*LoadBalancerSettings_ConsistentHashLB_HttpHeaderName); ok {
		return x.HttpHeaderName
	}
	return ""
}

func (m *LoadBalancerSettings_ConsistentHashLB) GetHttpCookie() *LoadBalancerSettings_ConsistentHashLB_HTTPCookie {
	if x, ok := m.GetHashKey().(*LoadBalancerSettings_ConsistentHashLB_HttpCookie); ok {
		return x.HttpCookie
	}
	return nil
}

func (m *LoadBalancerSettings_ConsistentHashLB) GetUseSourceIp() bool {
	if x, ok := m.GetHashKey().(*LoadBalancerSettings_ConsistentHashLB_UseSourceIp); ok {
		return x.UseSourceIp
	}
	return false
}

func (m *LoadBalancerSettings_ConsistentHashLB) GetMinimumRingSize() uint64 {
	if m != nil {
		return m.MinimumRingSize
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LoadBalancerSettings_ConsistentHashLB) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LoadBalancerSettings_ConsistentHashLB_OneofMarshaler, _LoadBalancerSettings_ConsistentHashLB_OneofUnmarshaler, _LoadBalancerSettings_ConsistentHashLB_OneofSizer, []interface{}{
		(*LoadBalancerSettings_ConsistentHashLB_HttpHeaderName)(nil),
		(*LoadBalancerSettings_ConsistentHashLB_HttpCookie)(nil),
		(*LoadBalancerSettings_ConsistentHashLB_UseSourceIp)(nil),
	}
}

func _LoadBalancerSettings_ConsistentHashLB_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LoadBalancerSettings_ConsistentHashLB)
	// hash_key
	switch x := m.HashKey.(type) {
	case *LoadBalancerSettings_ConsistentHashLB_HttpHeaderName:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.HttpHeaderName)
	case *LoadBalancerSettings_ConsistentHashLB_HttpCookie:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HttpCookie); err != nil {
			return err
		}
	case *LoadBalancerSettings_ConsistentHashLB_UseSourceIp:
		t := uint64(0)
		if x.UseSourceIp {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("LoadBalancerSettings_ConsistentHashLB.HashKey has unexpected type %T", x)
	}
	return nil
}

func _LoadBalancerSettings_ConsistentHashLB_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LoadBalancerSettings_ConsistentHashLB)
	switch tag {
	case 1: // hash_key.http_header_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.HashKey = &LoadBalancerSettings_ConsistentHashLB_HttpHeaderName{x}
		return true, err
	case 2: // hash_key.http_cookie
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoadBalancerSettings_ConsistentHashLB_HTTPCookie)
		err := b.DecodeMessage(msg)
		m.HashKey = &LoadBalancerSettings_ConsistentHashLB_HttpCookie{msg}
		return true, err
	case 3: // hash_key.use_source_ip
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.HashKey = &LoadBalancerSettings_ConsistentHashLB_UseSourceIp{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _LoadBalancerSettings_ConsistentHashLB_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LoadBalancerSettings_ConsistentHashLB)
	// hash_key
	switch x := m.HashKey.(type) {
	case *LoadBalancerSettings_ConsistentHashLB_HttpHeaderName:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.HttpHeaderName)))
		n += len(x.HttpHeaderName)
	case *LoadBalancerSettings_ConsistentHashLB_HttpCookie:
		s := proto.Size(x.HttpCookie)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LoadBalancerSettings_ConsistentHashLB_UseSourceIp:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Describes a HTTP cookie that will be used as the hash key for the
// Consistent Hash load balancer. If the cookie is not present, it will
// be generated.
type LoadBalancerSettings_ConsistentHashLB_HTTPCookie struct {
	// REQUIRED. Name of the cookie.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Path to set for the cookie.
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// REQUIRED. Lifetime of the cookie.
	Ttl *time.Duration `protobuf:"bytes,3,opt,name=ttl,stdduration" json:"ttl,omitempty"`
}

func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) Reset() {
	*m = LoadBalancerSettings_ConsistentHashLB_HTTPCookie{}
}
func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) String() string {
	return proto.CompactTextString(m)
}
func (*LoadBalancerSettings_ConsistentHashLB_HTTPCookie) ProtoMessage() {}
func (*LoadBalancerSettings_ConsistentHashLB_HTTPCookie) Descriptor() ([]byte, []int) {
	return fileDescriptorDestinationRule, []int{3, 0, 0}
}

func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) GetTtl() *time.Duration {
	if m != nil {
		return m.Ttl
	}
	return nil
}

// Connection pool settings for an upstream host. The settings apply to
// each individual host in the upstream service.  See Envoy's [circuit
// breaker](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/circuit_breaking)
// for more details. Connection pool settings can be applied at the TCP
// level as well as at HTTP level.
//
// For example, the following rule sets a limit of 100 connections to redis
// service called myredissrv with a connect timeout of 30ms
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: DestinationRule
// metadata:
//   name: bookinfo-redis
// spec:
//   host: myredissrv.prod.svc.cluster.local
//   trafficPolicy:
//     connectionPool:
//       tcp:
//         maxConnections: 100
//         connectTimeout: 30ms
//         tcpKeepalive:
//           time: 7200s
//           interval: 75s
// ```
type ConnectionPoolSettings struct {
	// Settings common to both HTTP and TCP upstream connections.
	Tcp *ConnectionPoolSettings_TCPSettings `protobuf:"bytes,1,opt,name=tcp" json:"tcp,omitempty"`
	// HTTP connection pool settings.
	Http *ConnectionPoolSettings_HTTPSettings `protobuf:"bytes,2,opt,name=http" json:"http,omitempty"`
}

func (m *ConnectionPoolSettings) Reset()         { *m = ConnectionPoolSettings{} }
func (m *ConnectionPoolSettings) String() string { return proto.CompactTextString(m) }
func (*ConnectionPoolSettings) ProtoMessage()    {}
func (*ConnectionPoolSettings) Descriptor() ([]byte, []int) {
	return fileDescriptorDestinationRule, []int{4}
}

func (m *ConnectionPoolSettings) GetTcp() *ConnectionPoolSettings_TCPSettings {
	if m != nil {
		return m.Tcp
	}
	return nil
}

func (m *ConnectionPoolSettings) GetHttp() *ConnectionPoolSettings_HTTPSettings {
	if m != nil {
		return m.Http
	}
	return nil
}

// Settings common to both HTTP and TCP upstream connections.
type ConnectionPoolSettings_TCPSettings struct {
	// Maximum number of HTTP1 /TCP connections to a destination host.
	MaxConnections int32 `protobuf:"varint,1,opt,name=max_connections,json=maxConnections,proto3" json:"max_connections,omitempty"`
	// TCP connection timeout.
	ConnectTimeout *google_protobuf.Duration `protobuf:"bytes,2,opt,name=connect_timeout,json=connectTimeout" json:"connect_timeout,omitempty"`
	// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
	TcpKeepalive *ConnectionPoolSettings_TCPSettings_TcpKeepalive `protobuf:"bytes,3,opt,name=tcp_keepalive,json=tcpKeepalive" json:"tcp_keepalive,omitempty"`
}

func (m *ConnectionPoolSettings_TCPSettings) Reset()         { *m = ConnectionPoolSettings_TCPSettings{} }
func (m *ConnectionPoolSettings_TCPSettings) String() string { return proto.CompactTextString(m) }
func (*ConnectionPoolSettings_TCPSettings) ProtoMessage()    {}
func (*ConnectionPoolSettings_TCPSettings) Descriptor() ([]byte, []int) {
	return fileDescriptorDestinationRule, []int{4, 0}
}

func (m *ConnectionPoolSettings_TCPSettings) GetMaxConnections() int32 {
	if m != nil {
		return m.MaxConnections
	}
	return 0
}

func (m *ConnectionPoolSettings_TCPSettings) GetConnectTimeout() *google_protobuf.Duration {
	if m != nil {
		return m.ConnectTimeout
	}
	return nil
}

func (m *ConnectionPoolSettings_TCPSettings) GetTcpKeepalive() *ConnectionPoolSettings_TCPSettings_TcpKeepalive {
	if m != nil {
		return m.TcpKeepalive
	}
	return nil
}

// TCP keepalive.
type ConnectionPoolSettings_TCPSettings_TcpKeepalive struct {
	// Maximum number of keepalive probes to send without response before
	// deciding the connection is dead. Default is to use the OS level configuration
	// (unless overridden, Linux defaults to 9.)
	Probes uint32 `protobuf:"varint,1,opt,name=probes,proto3" json:"probes,omitempty"`
	// The time duration a connection needs to be idle before keep-alive
	// probes start being sent. Default is to use the OS level configuration
	// (unless overridden, Linux defaults to 7200s (ie 2 hours.)
	Time *google_protobuf.Duration `protobuf:"bytes,2,opt,name=time" json:"time,omitempty"`
	// The time duration between keep-alive probes.
	// Default is to use the OS level configuration
	// (unless overridden, Linux defaults to 75s.)
	Interval *google_protobuf.Duration `protobuf:"bytes,3,opt,name=interval" json:"interval,omitempty"`
}

func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) Reset() {
	*m = ConnectionPoolSettings_TCPSettings_TcpKeepalive{}
}
func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) String() string {
	return proto.CompactTextString(m)
}
func (*ConnectionPoolSettings_TCPSettings_TcpKeepalive) ProtoMessage() {}
func (*ConnectionPoolSettings_TCPSettings_TcpKeepalive) Descriptor() ([]byte, []int) {
	return fileDescriptorDestinationRule, []int{4, 0, 0}
}

func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) GetProbes() uint32 {
	if m != nil {
		return m.Probes
	}
	return 0
}

func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) GetTime() *google_protobuf.Duration {
	if m != nil {
		return m.Time
	}
	return nil
}

func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) GetInterval() *google_protobuf.Duration {
	if m != nil {
		return m.Interval
	}
	return nil
}

// Settings applicable to HTTP1.1/HTTP2/GRPC connections.
type ConnectionPoolSettings_HTTPSettings struct {
	// Maximum number of pending HTTP requests to a destination. Default 1024.
	Http1MaxPendingRequests int32 `protobuf:"varint,1,opt,name=http1_max_pending_requests,json=http1MaxPendingRequests,proto3" json:"http1_max_pending_requests,omitempty"`
	// Maximum number of requests to a backend. Default 1024.
	Http2MaxRequests int32 `protobuf:"varint,2,opt,name=http2_max_requests,json=http2MaxRequests,proto3" json:"http2_max_requests,omitempty"`
	// Maximum number of requests per connection to a backend. Setting this
	// parameter to 1 disables keep alive.
	MaxRequestsPerConnection int32 `protobuf:"varint,3,opt,name=max_requests_per_connection,json=maxRequestsPerConnection,proto3" json:"max_requests_per_connection,omitempty"`
	// Maximum number of retries that can be outstanding to all hosts in a
	// cluster at a given time. Defaults to 3.
	MaxRetries int32 `protobuf:"varint,4,opt,name=max_retries,json=maxRetries,proto3" json:"max_retries,omitempty"`
}

func (m *ConnectionPoolSettings_HTTPSettings) Reset()         { *m = ConnectionPoolSettings_HTTPSettings{} }
func (m *ConnectionPoolSettings_HTTPSettings) String() string { return proto.CompactTextString(m) }
func (*ConnectionPoolSettings_HTTPSettings) ProtoMessage()    {}
func (*ConnectionPoolSettings_HTTPSettings) Descriptor() ([]byte, []int) {
	return fileDescriptorDestinationRule, []int{4, 1}
}

func (m *ConnectionPoolSettings_HTTPSettings) GetHttp1MaxPendingRequests() int32 {
	if m != nil {
		return m.Http1MaxPendingRequests
	}
	return 0
}

func (m *ConnectionPoolSettings_HTTPSettings) GetHttp2MaxRequests() int32 {
	if m != nil {
		return m.Http2MaxRequests
	}
	return 0
}

func (m *ConnectionPoolSettings_HTTPSettings) GetMaxRequestsPerConnection() int32 {
	if m != nil {
		return m.MaxRequestsPerConnection
	}
	return 0
}

func (m *ConnectionPoolSettings_HTTPSettings) GetMaxRetries() int32 {
	if m != nil {
		return m.MaxRetries
	}
	return 0
}

// A Circuit breaker implementation that tracks the status of each
// individual host in the upstream service.  Applicable to both HTTP and
// TCP services.  For HTTP services, hosts that continually return 5xx
// errors for API calls are ejected from the pool for a pre-defined period
// of time. For TCP services, connection timeouts or connection
// failures to a given host counts as an error when measuring the
// consecutive errors metric. See Envoy's [outlier
// detection](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/outlier)
// for more details.
//
// The following rule sets a connection pool size of 100 connections and
// 1000 concurrent HTTP2 requests, with no more than 10 req/connection to
// "reviews" service. In addition, it configures upstream hosts to be
// scanned every 5 mins, such that any host that fails 7 consecutive times
// with 5XX error code will be ejected for 15 minutes.
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: DestinationRule
// metadata:
//   name: reviews-cb-policy
// spec:
//   host: reviews.prod.svc.cluster.local
//   trafficPolicy:
//     connectionPool:
//       tcp:
//         maxConnections: 100
//       http:
//         http2MaxRequests: 1000
//         maxRequestsPerConnection: 10
//     outlierDetection:
//       consecutiveErrors: 7
//       interval: 5m
//       baseEjectionTime: 15m
// ```
type OutlierDetection struct {
	// Number of errors before a host is ejected from the connection
	// pool. Defaults to 5. When the upstream host is accessed over HTTP, a
	// 502, 503 or 504 return code qualifies as an error. When the upstream host
	// is accessed over an opaque TCP connection, connect timeouts and
	// connection error/failure events qualify as an error.
	ConsecutiveErrors int32 `protobuf:"varint,1,opt,name=consecutive_errors,json=consecutiveErrors,proto3" json:"consecutive_errors,omitempty"`
	// Time interval between ejection sweep analysis. format:
	// 1h/1m/1s/1ms. MUST BE >=1ms. Default is 10s.
	Interval *google_protobuf.Duration `protobuf:"bytes,2,opt,name=interval" json:"interval,omitempty"`
	// Minimum ejection duration. A host will remain ejected for a period
	// equal to the product of minimum ejection duration and the number of
	// times the host has been ejected. This technique allows the system to
	// automatically increase the ejection period for unhealthy upstream
	// servers. format: 1h/1m/1s/1ms. MUST BE >=1ms. Default is 30s.
	BaseEjectionTime *google_protobuf.Duration `protobuf:"bytes,3,opt,name=base_ejection_time,json=baseEjectionTime" json:"base_ejection_time,omitempty"`
	// Maximum % of hosts in the load balancing pool for the upstream
	// service that can be ejected. Defaults to 10%.
	MaxEjectionPercent int32 `protobuf:"varint,4,opt,name=max_ejection_percent,json=maxEjectionPercent,proto3" json:"max_ejection_percent,omitempty"`
	// Outlier detection will be enabled as long as the associated load balancing
	// pool has at least min_health_percent hosts in healthy mode. When the
	// percentage of healthy hosts in the load balancing pool drops below this
	// threshold, outlier detection will be disabled and the proxy will load balance
	// across all hosts in the pool (healthy and unhealthy).  The default is 50%.
	MinHealthPercent int32 `protobuf:"varint,5,opt,name=min_health_percent,json=minHealthPercent,proto3" json:"min_health_percent,omitempty"`
}

func (m *OutlierDetection) Reset()                    { *m = OutlierDetection{} }
func (m *OutlierDetection) String() string            { return proto.CompactTextString(m) }
func (*OutlierDetection) ProtoMessage()               {}
func (*OutlierDetection) Descriptor() ([]byte, []int) { return fileDescriptorDestinationRule, []int{5} }

func (m *OutlierDetection) GetConsecutiveErrors() int32 {
	if m != nil {
		return m.ConsecutiveErrors
	}
	return 0
}

func (m *OutlierDetection) GetInterval() *google_protobuf.Duration {
	if m != nil {
		return m.Interval
	}
	return nil
}

func (m *OutlierDetection) GetBaseEjectionTime() *google_protobuf.Duration {
	if m != nil {
		return m.BaseEjectionTime
	}
	return nil
}

func (m *OutlierDetection) GetMaxEjectionPercent() int32 {
	if m != nil {
		return m.MaxEjectionPercent
	}
	return 0
}

func (m *OutlierDetection) GetMinHealthPercent() int32 {
	if m != nil {
		return m.MinHealthPercent
	}
	return 0
}

// SSL/TLS related settings for upstream connections. See Envoy's [TLS
// context](https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/auth/cert.proto.html)
// for more details. These settings are common to both HTTP and TCP upstreams.
//
// For example, the following rule configures a client to use mutual TLS
// for connections to upstream database cluster.
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: DestinationRule
// metadata:
//   name: db-mtls
// spec:
//   host: mydbserver.prod.svc.cluster.local
//   trafficPolicy:
//     tls:
//       mode: MUTUAL
//       clientCertificate: /etc/certs/myclientcert.pem
//       privateKey: /etc/certs/client_private_key.pem
//       caCertificates: /etc/certs/rootcacerts.pem
// ```
//
// The following rule configures a client to use TLS when talking to a
// foreign service whose domain matches *.foo.com.
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: DestinationRule
// metadata:
//   name: tls-foo
// spec:
//   host: "*.foo.com"
//   trafficPolicy:
//     tls:
//       mode: SIMPLE
// ```
//
// The following rule configures a client to use Istio mutual TLS when talking
// to rating services.
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: DestinationRule
// metadata:
//   name: ratings-istio-mtls
// spec:
//   host: ratings.prod.svc.cluster.local
//   trafficPolicy:
//     tls:
//       mode: ISTIO_MUTUAL
// ```
type TLSSettings struct {
	// REQUIRED: Indicates whether connections to this port should be secured
	// using TLS. The value of this field determines how TLS is enforced.
	Mode TLSSettings_TLSmode `protobuf:"varint,1,opt,name=mode,proto3,enum=istio.networking.v1alpha3.TLSSettings_TLSmode" json:"mode,omitempty"`
	// REQUIRED if mode is `MUTUAL`. The path to the file holding the
	// client-side TLS certificate to use.
	// Should be empty if mode is `ISTIO_MUTUAL`.
	ClientCertificate string `protobuf:"bytes,2,opt,name=client_certificate,json=clientCertificate,proto3" json:"client_certificate,omitempty"`
	// REQUIRED if mode is `MUTUAL`. The path to the file holding the
	// client's private key.
	// Should be empty if mode is `ISTIO_MUTUAL`.
	PrivateKey string `protobuf:"bytes,3,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
	// OPTIONAL: The path to the file containing certificate authority
	// certificates to use in verifying a presented server certificate. If
	// omitted, the proxy will not verify the server's certificate.
	// Should be empty if mode is `ISTIO_MUTUAL`.
	CaCertificates string `protobuf:"bytes,4,opt,name=ca_certificates,json=caCertificates,proto3" json:"ca_certificates,omitempty"`
	// A list of alternate names to verify the subject identity in the
	// certificate. If specified, the proxy will verify that the server
	// certificate's subject alt name matches one of the specified values.
	SubjectAltNames []string `protobuf:"bytes,5,rep,name=subject_alt_names,json=subjectAltNames" json:"subject_alt_names,omitempty"`
	// SNI string to present to the server during TLS handshake.
	Sni string `protobuf:"bytes,6,opt,name=sni,proto3" json:"sni,omitempty"`
}

func (m *TLSSettings) Reset()                    { *m = TLSSettings{} }
func (m *TLSSettings) String() string            { return proto.CompactTextString(m) }
func (*TLSSettings) ProtoMessage()               {}
func (*TLSSettings) Descriptor() ([]byte, []int) { return fileDescriptorDestinationRule, []int{6} }

func (m *TLSSettings) GetMode() TLSSettings_TLSmode {
	if m != nil {
		return m.Mode
	}
	return TLSSettings_DISABLE
}

func (m *TLSSettings) GetClientCertificate() string {
	if m != nil {
		return m.ClientCertificate
	}
	return ""
}

func (m *TLSSettings) GetPrivateKey() string {
	if m != nil {
		return m.PrivateKey
	}
	return ""
}

func (m *TLSSettings) GetCaCertificates() string {
	if m != nil {
		return m.CaCertificates
	}
	return ""
}

func (m *TLSSettings) GetSubjectAltNames() []string {
	if m != nil {
		return m.SubjectAltNames
	}
	return nil
}

func (m *TLSSettings) GetSni() string {
	if m != nil {
		return m.Sni
	}
	return ""
}

func init() {
	proto.RegisterType((*DestinationRule)(nil), "istio.networking.v1alpha3.DestinationRule")
	proto.RegisterType((*TrafficPolicy)(nil), "istio.networking.v1alpha3.TrafficPolicy")
	proto.RegisterType((*TrafficPolicy_PortTrafficPolicy)(nil), "istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy")
	proto.RegisterType((*Subset)(nil), "istio.networking.v1alpha3.Subset")
	proto.RegisterType((*LoadBalancerSettings)(nil), "istio.networking.v1alpha3.LoadBalancerSettings")
	proto.RegisterType((*LoadBalancerSettings_ConsistentHashLB)(nil), "istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB")
	proto.RegisterType((*LoadBalancerSettings_ConsistentHashLB_HTTPCookie)(nil), "istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie")
	proto.RegisterType((*ConnectionPoolSettings)(nil), "istio.networking.v1alpha3.ConnectionPoolSettings")
	proto.RegisterType((*ConnectionPoolSettings_TCPSettings)(nil), "istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings")
	proto.RegisterType((*ConnectionPoolSettings_TCPSettings_TcpKeepalive)(nil), "istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive")
	proto.RegisterType((*ConnectionPoolSettings_HTTPSettings)(nil), "istio.networking.v1alpha3.ConnectionPoolSettings.HTTPSettings")
	proto.RegisterType((*OutlierDetection)(nil), "istio.networking.v1alpha3.OutlierDetection")
	proto.RegisterType((*TLSSettings)(nil), "istio.networking.v1alpha3.TLSSettings")
	proto.RegisterEnum("istio.networking.v1alpha3.LoadBalancerSettings_SimpleLB", LoadBalancerSettings_SimpleLB_name, LoadBalancerSettings_SimpleLB_value)
	proto.RegisterEnum("istio.networking.v1alpha3.TLSSettings_TLSmode", TLSSettings_TLSmode_name, TLSSettings_TLSmode_value)
}
func (m *DestinationRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DestinationRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Host) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Host)))
		i += copy(dAtA[i:], m.Host)
	}
	if m.TrafficPolicy != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.TrafficPolicy.Size()))
		n1, err := m.TrafficPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Subsets) > 0 {
		for _, msg := range m.Subsets {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDestinationRule(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ConfigScope != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.ConfigScope))
	}
	return i, nil
}

func (m *TrafficPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrafficPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LoadBalancer != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.LoadBalancer.Size()))
		n2, err := m.LoadBalancer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.ConnectionPool != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.ConnectionPool.Size()))
		n3, err := m.ConnectionPool.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.OutlierDetection != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.OutlierDetection.Size()))
		n4, err := m.OutlierDetection.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Tls != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Tls.Size()))
		n5, err := m.Tls.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.PortLevelSettings) > 0 {
		for _, msg := range m.PortLevelSettings {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintDestinationRule(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrafficPolicy_PortTrafficPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrafficPolicy_PortTrafficPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Port != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Port.Size()))
		n6, err := m.Port.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.LoadBalancer != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.LoadBalancer.Size()))
		n7, err := m.LoadBalancer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.ConnectionPool != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.ConnectionPool.Size()))
		n8, err := m.ConnectionPool.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.OutlierDetection != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.OutlierDetection.Size()))
		n9, err := m.OutlierDetection.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Tls != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Tls.Size()))
		n10, err := m.Tls.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *Subset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Subset) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0x12
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovDestinationRule(uint64(len(k))) + 1 + len(v) + sovDestinationRule(uint64(len(v)))
			i = encodeVarintDestinationRule(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintDestinationRule(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintDestinationRule(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.TrafficPolicy != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.TrafficPolicy.Size()))
		n11, err := m.TrafficPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *LoadBalancerSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadBalancerSettings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LbPolicy != nil {
		nn12, err := m.LbPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn12
	}
	return i, nil
}

func (m *LoadBalancerSettings_Simple) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintDestinationRule(dAtA, i, uint64(m.Simple))
	return i, nil
}
func (m *LoadBalancerSettings_ConsistentHash) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ConsistentHash != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.ConsistentHash.Size()))
		n13, err := m.ConsistentHash.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *LoadBalancerSettings_ConsistentHashLB) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadBalancerSettings_ConsistentHashLB) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HashKey != nil {
		nn14, err := m.HashKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn14
	}
	if m.MinimumRingSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MinimumRingSize))
	}
	return i, nil
}

func (m *LoadBalancerSettings_ConsistentHashLB_HttpHeaderName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa
	i++
	i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.HttpHeaderName)))
	i += copy(dAtA[i:], m.HttpHeaderName)
	return i, nil
}
func (m *LoadBalancerSettings_ConsistentHashLB_HttpCookie) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.HttpCookie != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.HttpCookie.Size()))
		n15, err := m.HttpCookie.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *LoadBalancerSettings_ConsistentHashLB_UseSourceIp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x18
	i++
	if m.UseSourceIp {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if m.Ttl != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(types.SizeOfStdDuration(*m.Ttl)))
		n16, err := types.StdDurationMarshalTo(*m.Ttl, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *ConnectionPoolSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectionPoolSettings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tcp != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Tcp.Size()))
		n17, err := m.Tcp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Http != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Http.Size()))
		n18, err := m.Http.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *ConnectionPoolSettings_TCPSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectionPoolSettings_TCPSettings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MaxConnections != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MaxConnections))
	}
	if m.ConnectTimeout != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.ConnectTimeout.Size()))
		n19, err := m.ConnectTimeout.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.TcpKeepalive != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.TcpKeepalive.Size()))
		n20, err := m.TcpKeepalive.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Probes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Probes))
	}
	if m.Time != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Time.Size()))
		n21, err := m.Time.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Interval != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Interval.Size()))
		n22, err := m.Interval.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *ConnectionPoolSettings_HTTPSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectionPoolSettings_HTTPSettings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Http1MaxPendingRequests != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Http1MaxPendingRequests))
	}
	if m.Http2MaxRequests != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Http2MaxRequests))
	}
	if m.MaxRequestsPerConnection != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MaxRequestsPerConnection))
	}
	if m.MaxRetries != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MaxRetries))
	}
	return i, nil
}

func (m *OutlierDetection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutlierDetection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConsecutiveErrors != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.ConsecutiveErrors))
	}
	if m.Interval != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Interval.Size()))
		n23, err := m.Interval.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.BaseEjectionTime != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.BaseEjectionTime.Size()))
		n24, err := m.BaseEjectionTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.MaxEjectionPercent != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MaxEjectionPercent))
	}
	if m.MinHealthPercent != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MinHealthPercent))
	}
	return i, nil
}

func (m *TLSSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSSettings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Mode))
	}
	if len(m.ClientCertificate) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.ClientCertificate)))
		i += copy(dAtA[i:], m.ClientCertificate)
	}
	if len(m.PrivateKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.PrivateKey)))
		i += copy(dAtA[i:], m.PrivateKey)
	}
	if len(m.CaCertificates) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.CaCertificates)))
		i += copy(dAtA[i:], m.CaCertificates)
	}
	if len(m.SubjectAltNames) > 0 {
		for _, s := range m.SubjectAltNames {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Sni) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Sni)))
		i += copy(dAtA[i:], m.Sni)
	}
	return i, nil
}

func encodeVarintDestinationRule(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *DestinationRule) Size() (n int) {
	var l int
	_ = l
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	if m.TrafficPolicy != nil {
		l = m.TrafficPolicy.Size()
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	if len(m.Subsets) > 0 {
		for _, e := range m.Subsets {
			l = e.Size()
			n += 1 + l + sovDestinationRule(uint64(l))
		}
	}
	if m.ConfigScope != 0 {
		n += 1 + sovDestinationRule(uint64(m.ConfigScope))
	}
	return n
}

func (m *TrafficPolicy) Size() (n int) {
	var l int
	_ = l
	if m.LoadBalancer != nil {
		l = m.LoadBalancer.Size()
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	if m.ConnectionPool != nil {
		l = m.ConnectionPool.Size()
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	if m.OutlierDetection != nil {
		l = m.OutlierDetection.Size()
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	if m.Tls != nil {
		l = m.Tls.Size()
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	if len(m.PortLevelSettings) > 0 {
		for _, e := range m.PortLevelSettings {
			l = e.Size()
			n += 1 + l + sovDestinationRule(uint64(l))
		}
	}
	return n
}

func (m *TrafficPolicy_PortTrafficPolicy) Size() (n int) {
	var l int
	_ = l
	if m.Port != nil {
		l = m.Port.Size()
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	if m.LoadBalancer != nil {
		l = m.LoadBalancer.Size()
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	if m.ConnectionPool != nil {
		l = m.ConnectionPool.Size()
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	if m.OutlierDetection != nil {
		l = m.OutlierDetection.Size()
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	if m.Tls != nil {
		l = m.Tls.Size()
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	return n
}

func (m *Subset) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovDestinationRule(uint64(len(k))) + 1 + len(v) + sovDestinationRule(uint64(len(v)))
			n += mapEntrySize + 1 + sovDestinationRule(uint64(mapEntrySize))
		}
	}
	if m.TrafficPolicy != nil {
		l = m.TrafficPolicy.Size()
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	return n
}

func (m *LoadBalancerSettings) Size() (n int) {
	var l int
	_ = l
	if m.LbPolicy != nil {
		n += m.LbPolicy.Size()
	}
	return n
}

func (m *LoadBalancerSettings_Simple) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovDestinationRule(uint64(m.Simple))
	return n
}
func (m *LoadBalancerSettings_ConsistentHash) Size() (n int) {
	var l int
	_ = l
	if m.ConsistentHash != nil {
		l = m.ConsistentHash.Size()
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	return n
}
func (m *LoadBalancerSettings_ConsistentHashLB) Size() (n int) {
	var l int
	_ = l
	if m.HashKey != nil {
		n += m.HashKey.Size()
	}
	if m.MinimumRingSize != 0 {
		n += 1 + sovDestinationRule(uint64(m.MinimumRingSize))
	}
	return n
}

func (m *LoadBalancerSettings_ConsistentHashLB_HttpHeaderName) Size() (n int) {
	var l int
	_ = l
	l = len(m.HttpHeaderName)
	n += 1 + l + sovDestinationRule(uint64(l))
	return n
}
func (m *LoadBalancerSettings_ConsistentHashLB_HttpCookie) Size() (n int) {
	var l int
	_ = l
	if m.HttpCookie != nil {
		l = m.HttpCookie.Size()
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	return n
}
func (m *LoadBalancerSettings_ConsistentHashLB_UseSourceIp) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	if m.Ttl != nil {
		l = types.SizeOfStdDuration(*m.Ttl)
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	return n
}

func (m *ConnectionPoolSettings) Size() (n int) {
	var l int
	_ = l
	if m.Tcp != nil {
		l = m.Tcp.Size()
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	if m.Http != nil {
		l = m.Http.Size()
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	return n
}

func (m *ConnectionPoolSettings_TCPSettings) Size() (n int) {
	var l int
	_ = l
	if m.MaxConnections != 0 {
		n += 1 + sovDestinationRule(uint64(m.MaxConnections))
	}
	if m.ConnectTimeout != nil {
		l = m.ConnectTimeout.Size()
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	if m.TcpKeepalive != nil {
		l = m.TcpKeepalive.Size()
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	return n
}

func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) Size() (n int) {
	var l int
	_ = l
	if m.Probes != 0 {
		n += 1 + sovDestinationRule(uint64(m.Probes))
	}
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	if m.Interval != nil {
		l = m.Interval.Size()
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	return n
}

func (m *ConnectionPoolSettings_HTTPSettings) Size() (n int) {
	var l int
	_ = l
	if m.Http1MaxPendingRequests != 0 {
		n += 1 + sovDestinationRule(uint64(m.Http1MaxPendingRequests))
	}
	if m.Http2MaxRequests != 0 {
		n += 1 + sovDestinationRule(uint64(m.Http2MaxRequests))
	}
	if m.MaxRequestsPerConnection != 0 {
		n += 1 + sovDestinationRule(uint64(m.MaxRequestsPerConnection))
	}
	if m.MaxRetries != 0 {
		n += 1 + sovDestinationRule(uint64(m.MaxRetries))
	}
	return n
}

func (m *OutlierDetection) Size() (n int) {
	var l int
	_ = l
	if m.ConsecutiveErrors != 0 {
		n += 1 + sovDestinationRule(uint64(m.ConsecutiveErrors))
	}
	if m.Interval != nil {
		l = m.Interval.Size()
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	if m.BaseEjectionTime != nil {
		l = m.BaseEjectionTime.Size()
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	if m.MaxEjectionPercent != 0 {
		n += 1 + sovDestinationRule(uint64(m.MaxEjectionPercent))
	}
	if m.MinHealthPercent != 0 {
		n += 1 + sovDestinationRule(uint64(m.MinHealthPercent))
	}
	return n
}

func (m *TLSSettings) Size() (n int) {
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovDestinationRule(uint64(m.Mode))
	}
	l = len(m.ClientCertificate)
	if l > 0 {
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	l = len(m.PrivateKey)
	if l > 0 {
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	l = len(m.CaCertificates)
	if l > 0 {
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	if len(m.SubjectAltNames) > 0 {
		for _, s := range m.SubjectAltNames {
			l = len(s)
			n += 1 + l + sovDestinationRule(uint64(l))
		}
	}
	l = len(m.Sni)
	if l > 0 {
		n += 1 + l + sovDestinationRule(uint64(l))
	}
	return n
}

func sovDestinationRule(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDestinationRule(x uint64) (n int) {
	return sovDestinationRule(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DestinationRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDestinationRule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DestinationRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DestinationRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrafficPolicy == nil {
				m.TrafficPolicy = &TrafficPolicy{}
			}
			if err := m.TrafficPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subsets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subsets = append(m.Subsets, &Subset{})
			if err := m.Subsets[len(m.Subsets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigScope", wireType)
			}
			m.ConfigScope = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigScope |= (ConfigScope(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDestinationRule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDestinationRule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrafficPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDestinationRule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrafficPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrafficPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LoadBalancer == nil {
				m.LoadBalancer = &LoadBalancerSettings{}
			}
			if err := m.LoadBalancer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConnectionPool == nil {
				m.ConnectionPool = &ConnectionPoolSettings{}
			}
			if err := m.ConnectionPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutlierDetection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutlierDetection == nil {
				m.OutlierDetection = &OutlierDetection{}
			}
			if err := m.OutlierDetection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tls == nil {
				m.Tls = &TLSSettings{}
			}
			if err := m.Tls.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortLevelSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortLevelSettings = append(m.PortLevelSettings, &TrafficPolicy_PortTrafficPolicy{})
			if err := m.PortLevelSettings[len(m.PortLevelSettings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDestinationRule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDestinationRule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrafficPolicy_PortTrafficPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDestinationRule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortTrafficPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortTrafficPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Port == nil {
				m.Port = &PortSelector{}
			}
			if err := m.Port.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LoadBalancer == nil {
				m.LoadBalancer = &LoadBalancerSettings{}
			}
			if err := m.LoadBalancer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConnectionPool == nil {
				m.ConnectionPool = &ConnectionPoolSettings{}
			}
			if err := m.ConnectionPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutlierDetection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutlierDetection == nil {
				m.OutlierDetection = &OutlierDetection{}
			}
			if err := m.OutlierDetection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tls == nil {
				m.Tls = &TLSSettings{}
			}
			if err := m.Tls.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDestinationRule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDestinationRule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDestinationRule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDestinationRule
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDestinationRule
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDestinationRule
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDestinationRule
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthDestinationRule
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDestinationRule(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthDestinationRule
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrafficPolicy == nil {
				m.TrafficPolicy = &TrafficPolicy{}
			}
			if err := m.TrafficPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDestinationRule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDestinationRule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadBalancerSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDestinationRule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadBalancerSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadBalancerSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Simple", wireType)
			}
			var v LoadBalancerSettings_SimpleLB
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (LoadBalancerSettings_SimpleLB(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LbPolicy = &LoadBalancerSettings_Simple{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsistentHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LoadBalancerSettings_ConsistentHashLB{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LbPolicy = &LoadBalancerSettings_ConsistentHash{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDestinationRule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDestinationRule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadBalancerSettings_ConsistentHashLB) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDestinationRule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsistentHashLB: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsistentHashLB: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpHeaderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashKey = &LoadBalancerSettings_ConsistentHashLB_HttpHeaderName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpCookie", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LoadBalancerSettings_ConsistentHashLB_HTTPCookie{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HashKey = &LoadBalancerSettings_ConsistentHashLB_HttpCookie{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseSourceIp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.HashKey = &LoadBalancerSettings_ConsistentHashLB_UseSourceIp{b}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumRingSize", wireType)
			}
			m.MinimumRingSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumRingSize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDestinationRule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDestinationRule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDestinationRule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPCookie: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPCookie: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ttl == nil {
				m.Ttl = new(time.Duration)
			}
			if err := types.StdDurationUnmarshal(m.Ttl, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDestinationRule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDestinationRule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionPoolSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDestinationRule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionPoolSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionPoolSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tcp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tcp == nil {
				m.Tcp = &ConnectionPoolSettings_TCPSettings{}
			}
			if err := m.Tcp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Http == nil {
				m.Http = &ConnectionPoolSettings_HTTPSettings{}
			}
			if err := m.Http.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDestinationRule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDestinationRule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionPoolSettings_TCPSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDestinationRule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TCPSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TCPSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxConnections", wireType)
			}
			m.MaxConnections = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxConnections |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConnectTimeout == nil {
				m.ConnectTimeout = &google_protobuf.Duration{}
			}
			if err := m.ConnectTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpKeepalive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TcpKeepalive == nil {
				m.TcpKeepalive = &ConnectionPoolSettings_TCPSettings_TcpKeepalive{}
			}
			if err := m.TcpKeepalive.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDestinationRule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDestinationRule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDestinationRule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpKeepalive: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpKeepalive: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Probes", wireType)
			}
			m.Probes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Probes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &google_protobuf.Duration{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interval == nil {
				m.Interval = &google_protobuf.Duration{}
			}
			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDestinationRule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDestinationRule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionPoolSettings_HTTPSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDestinationRule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http1MaxPendingRequests", wireType)
			}
			m.Http1MaxPendingRequests = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Http1MaxPendingRequests |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http2MaxRequests", wireType)
			}
			m.Http2MaxRequests = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Http2MaxRequests |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequestsPerConnection", wireType)
			}
			m.MaxRequestsPerConnection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRequestsPerConnection |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRetries", wireType)
			}
			m.MaxRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRetries |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDestinationRule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDestinationRule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutlierDetection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDestinationRule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutlierDetection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutlierDetection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsecutiveErrors", wireType)
			}
			m.ConsecutiveErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConsecutiveErrors |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interval == nil {
				m.Interval = &google_protobuf.Duration{}
			}
			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseEjectionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BaseEjectionTime == nil {
				m.BaseEjectionTime = &google_protobuf.Duration{}
			}
			if err := m.BaseEjectionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxEjectionPercent", wireType)
			}
			m.MaxEjectionPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxEjectionPercent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinHealthPercent", wireType)
			}
			m.MinHealthPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinHealthPercent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDestinationRule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDestinationRule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDestinationRule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TLSSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TLSSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (TLSSettings_TLSmode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientCertificate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientCertificate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaCertificates", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaCertificates = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubjectAltNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubjectAltNames = append(m.SubjectAltNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sni", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDestinationRule
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sni = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDestinationRule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDestinationRule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDestinationRule(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDestinationRule
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDestinationRule
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDestinationRule
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDestinationRule
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDestinationRule(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDestinationRule = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDestinationRule   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("networking/v1alpha3/destination_rule.proto", fileDescriptorDestinationRule)
}

var fileDescriptorDestinationRule = []byte{
	// 1418 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0xcd, 0x6e, 0x1b, 0xb7,
	0x16, 0xb6, 0x7e, 0x63, 0x1f, 0xd9, 0xb2, 0xcc, 0x6b, 0xe4, 0x2a, 0xba, 0x80, 0xe3, 0x08, 0x17,
	0x37, 0xbe, 0x69, 0x33, 0xaa, 0x1d, 0x14, 0x48, 0x13, 0xa4, 0x88, 0x65, 0x1b, 0x91, 0x1b, 0xd9,
	0x12, 0x28, 0x19, 0x28, 0xb2, 0x19, 0x50, 0x23, 0x5a, 0x62, 0x3c, 0x1a, 0x4e, 0x49, 0x8e, 0x6a,
	0xe7, 0x19, 0xba, 0x0e, 0xba, 0xed, 0xa6, 0xcf, 0x52, 0x74, 0xd5, 0x6d, 0xbb, 0x69, 0x91, 0x17,
	0xe8, 0xaa, 0x9b, 0x2e, 0x8a, 0x82, 0x1c, 0xea, 0xc7, 0x89, 0x23, 0xc7, 0x48, 0xb3, 0x23, 0x79,
	0xbe, 0xef, 0x90, 0x3c, 0xe7, 0x9b, 0x73, 0x38, 0x70, 0x27, 0xa0, 0xea, 0x6b, 0x2e, 0x4e, 0x58,
	0xd0, 0xab, 0x0c, 0x37, 0x89, 0x1f, 0xf6, 0xc9, 0xbd, 0x4a, 0x97, 0x4a, 0xc5, 0x02, 0xa2, 0x18,
	0x0f, 0x5c, 0x11, 0xf9, 0xd4, 0x09, 0x05, 0x57, 0x1c, 0xdd, 0x60, 0x52, 0x31, 0xee, 0x4c, 0x18,
	0xce, 0x88, 0x51, 0x5a, 0xeb, 0x71, 0xde, 0xf3, 0x69, 0xc5, 0x00, 0x3b, 0xd1, 0x71, 0xa5, 0x1b,
	0x09, 0xc3, 0x8f, 0xa9, 0xa5, 0xff, 0x5f, 0xb4, 0xcd, 0x90, 0x09, 0x15, 0x11, 0xdf, 0x95, 0x54,
	0x0c, 0x99, 0x67, 0x77, 0x29, 0xdd, 0xba, 0x08, 0x2a, 0x59, 0x97, 0x7a, 0x44, 0x58, 0xc8, 0x6a,
	0x8f, 0xf7, 0xb8, 0x19, 0x56, 0xf4, 0x28, 0x5e, 0x2d, 0xff, 0x95, 0x80, 0xe5, 0xdd, 0xc9, 0xc9,
	0x71, 0xe4, 0x53, 0x84, 0x20, 0xdd, 0xe7, 0x52, 0x15, 0x13, 0xeb, 0x89, 0x8d, 0x05, 0x6c, 0xc6,
	0xa8, 0x01, 0x79, 0x25, 0xc8, 0xf1, 0x31, 0xf3, 0xdc, 0x90, 0xfb, 0xcc, 0x3b, 0x2b, 0x26, 0xd7,
	0x13, 0x1b, 0xb9, 0xad, 0x0d, 0xe7, 0xad, 0xf7, 0x73, 0xda, 0x31, 0xa1, 0x69, 0xf0, 0x78, 0x49,
	0x4d, 0x4f, 0xd1, 0x43, 0xb8, 0x26, 0xa3, 0x8e, 0xa4, 0x4a, 0x16, 0x53, 0xeb, 0xa9, 0x8d, 0xdc,
	0xd6, 0xad, 0x19, 0x9e, 0x5a, 0x06, 0x89, 0x47, 0x0c, 0xb4, 0x0f, 0x8b, 0x1e, 0x0f, 0x8e, 0x59,
	0xcf, 0x95, 0x1e, 0x0f, 0x69, 0x31, 0xbd, 0x9e, 0xd8, 0xc8, 0x6f, 0xfd, 0x6f, 0x86, 0x87, 0x1d,
	0x03, 0x6f, 0x69, 0x34, 0xce, 0x79, 0x93, 0x49, 0xf9, 0x97, 0x2c, 0x2c, 0x9d, 0x3b, 0x28, 0x6a,
	0xc3, 0x92, 0xcf, 0x49, 0xd7, 0xed, 0x10, 0x9f, 0x04, 0x1e, 0x15, 0x26, 0x0e, 0xb9, 0xad, 0xca,
	0x0c, 0xef, 0x75, 0x4e, 0xba, 0x55, 0x0b, 0x6f, 0x51, 0xa5, 0x58, 0xd0, 0x93, 0x78, 0xd1, 0x9f,
	0x5a, 0x45, 0xcf, 0x60, 0xd9, 0xe3, 0x41, 0x40, 0x3d, 0x23, 0x90, 0x90, 0x73, 0xdf, 0x46, 0x70,
	0x73, 0xf6, 0xa9, 0x2d, 0xa3, 0xc9, 0xb9, 0x3f, 0xf6, 0x9c, 0xf7, 0xce, 0xad, 0xa3, 0x2f, 0x61,
	0x85, 0x47, 0xca, 0x67, 0x54, 0xb8, 0x5d, 0xaa, 0x62, 0x43, 0x31, 0x65, 0xbc, 0x7f, 0x34, 0xc3,
	0x7b, 0x23, 0xe6, 0xec, 0x8e, 0x28, 0xb8, 0xc0, 0x5f, 0x5b, 0x41, 0xf7, 0x21, 0xa5, 0x7c, 0x69,
	0xe2, 0x9b, 0x9b, 0x19, 0xdf, 0x76, 0xbd, 0x35, 0x3e, 0x9e, 0xa6, 0xa0, 0xe7, 0xf0, 0xaf, 0x90,
	0x0b, 0xe5, 0xfa, 0x74, 0x48, 0xb5, 0x5a, 0x63, 0x5b, 0x31, 0x63, 0x72, 0xfd, 0xe0, 0x5d, 0x55,
	0xe3, 0x34, 0xb9, 0x50, 0xe7, 0x75, 0xb4, 0xa2, 0xdd, 0xd6, 0xb5, 0xd7, 0xd1, 0x86, 0xa5, 0x97,
	0x29, 0x58, 0x79, 0x03, 0x88, 0x1e, 0x42, 0x5a, 0x43, 0x6d, 0xfa, 0x6e, 0xcf, 0xd8, 0x52, 0x73,
	0x5b, 0xd4, 0xa7, 0x9e, 0xe2, 0x02, 0x1b, 0xd2, 0x9b, 0x22, 0x48, 0x7e, 0x20, 0x11, 0xa4, 0x3e,
	0xa8, 0x08, 0xd2, 0xff, 0xa0, 0x08, 0x32, 0x57, 0x16, 0x41, 0xf9, 0xf7, 0x04, 0x64, 0xe3, 0x6f,
	0x57, 0x17, 0x95, 0x80, 0x0c, 0xe8, 0xa8, 0xa8, 0xe8, 0x31, 0xda, 0x83, 0xac, 0x4f, 0x3a, 0xd4,
	0x97, 0xc5, 0xa4, 0x91, 0xc5, 0xdd, 0x4b, 0x4b, 0x80, 0x53, 0x37, 0xf8, 0xbd, 0x40, 0x89, 0x33,
	0x6c, 0xc9, 0x17, 0xd4, 0xa6, 0xd4, 0x7b, 0xd5, 0xa6, 0xd2, 0x67, 0x90, 0x9b, 0xda, 0x07, 0x15,
	0x20, 0x75, 0x42, 0xcf, 0xec, 0xc9, 0xf5, 0x10, 0xad, 0x42, 0x66, 0x48, 0xfc, 0x88, 0x1a, 0x55,
	0x2c, 0xe0, 0x78, 0xf2, 0x20, 0x79, 0x3f, 0x51, 0xfe, 0x3e, 0x03, 0xab, 0x17, 0x09, 0x01, 0x61,
	0xc8, 0x4a, 0x36, 0x08, 0xfd, 0x38, 0x02, 0xf9, 0xad, 0xfb, 0x57, 0x54, 0x92, 0xd3, 0x32, 0xec,
	0x7a, 0xb5, 0x36, 0x87, 0xad, 0x27, 0x74, 0x62, 0xe4, 0x24, 0x99, 0x54, 0x34, 0x50, 0x6e, 0x9f,
	0xc8, 0xbe, 0x95, 0xe9, 0xe3, 0xab, 0x3a, 0xdf, 0x19, 0xbb, 0xa9, 0x11, 0xd9, 0x37, 0x9b, 0xe4,
	0xbd, 0x73, 0x6b, 0xa5, 0x3f, 0x92, 0x50, 0x78, 0x1d, 0x86, 0xee, 0x40, 0xa1, 0xaf, 0x54, 0xe8,
	0xf6, 0x29, 0xe9, 0x52, 0xe1, 0x4e, 0x32, 0xac, 0x1d, 0x68, 0x4b, 0xcd, 0x18, 0x0e, 0x75, 0xb6,
	0x03, 0xc8, 0x19, 0xac, 0xc7, 0xf9, 0x09, 0xa3, 0xf6, 0xa4, 0x4f, 0xdf, 0xf7, 0xa4, 0x4e, 0xad,
	0xdd, 0x6e, 0xee, 0x18, 0x97, 0xb5, 0x39, 0x0c, 0x7a, 0x87, 0x78, 0x86, 0xfe, 0x0b, 0x4b, 0x91,
	0xa4, 0xae, 0xe4, 0x91, 0xf0, 0xa8, 0xcb, 0x42, 0xa3, 0x8a, 0xf9, 0xda, 0x1c, 0xce, 0x45, 0x92,
	0xb6, 0xcc, 0xea, 0x7e, 0x88, 0xee, 0xc0, 0xca, 0x80, 0x05, 0x6c, 0x10, 0x0d, 0x5c, 0xc1, 0x82,
	0x9e, 0x2b, 0xd9, 0x8b, 0xb8, 0x9f, 0xa4, 0xf1, 0xb2, 0x35, 0x60, 0x16, 0xf4, 0x5a, 0xec, 0x05,
	0x2d, 0xf5, 0x00, 0x26, 0xbb, 0x5d, 0xa8, 0x68, 0x04, 0xe9, 0x90, 0xa8, 0xbe, 0xd5, 0x85, 0x19,
	0xa3, 0x4d, 0x48, 0x29, 0x35, 0xfa, 0xd0, 0x6f, 0x38, 0x71, 0xd3, 0x77, 0x46, 0x4d, 0xdf, 0xd9,
	0xb5, 0x4d, 0xbf, 0x9a, 0xfe, 0xf6, 0xd7, 0x9b, 0x09, 0xac, 0xb1, 0x55, 0x80, 0x79, 0x9d, 0x4d,
	0xf7, 0x84, 0x9e, 0x95, 0x6b, 0x30, 0x3f, 0x4a, 0x3d, 0x5a, 0x86, 0x1c, 0x6e, 0x1c, 0x1d, 0xee,
	0xba, 0xb8, 0x51, 0xdd, 0x3f, 0x2c, 0xcc, 0xa1, 0x3c, 0x40, 0x7d, 0x6f, 0xbb, 0xd5, 0x76, 0x77,
	0x1a, 0x87, 0x87, 0x85, 0x04, 0x02, 0xc8, 0xe2, 0xed, 0xc3, 0xdd, 0xc6, 0x41, 0x21, 0xa9, 0xc1,
	0xcd, 0xed, 0x56, 0xab, 0x5d, 0xc3, 0x8d, 0xa3, 0x27, 0xb5, 0x42, 0xaa, 0x9a, 0x83, 0x05, 0xbf,
	0x63, 0x3f, 0x91, 0xf2, 0xcb, 0x2c, 0x5c, 0xbf, 0xb8, 0xb2, 0xa0, 0x06, 0xa4, 0x94, 0x17, 0xda,
	0xba, 0xf9, 0xe8, 0xca, 0x95, 0xc9, 0x69, 0xef, 0x34, 0xa7, 0xca, 0x80, 0x17, 0x22, 0x0c, 0x69,
	0x9d, 0x17, 0x9b, 0xf2, 0xcf, 0xaf, 0xee, 0x51, 0x47, 0x7d, 0xec, 0xd2, 0xf8, 0x2a, 0xfd, 0x99,
	0x84, 0xdc, 0xd4, 0x46, 0xe8, 0x36, 0x2c, 0x0f, 0xc8, 0xa9, 0x3b, 0x29, 0x8a, 0xd2, 0x5c, 0x20,
	0x83, 0xf3, 0x03, 0x72, 0x3a, 0x71, 0x2b, 0x51, 0x75, 0x5c, 0x83, 0x5d, 0xc5, 0x06, 0x94, 0x47,
	0xca, 0x9e, 0xeb, 0xed, 0xa9, 0x19, 0xd7, 0xda, 0x76, 0x4c, 0x40, 0x1c, 0x96, 0x94, 0x17, 0xba,
	0x27, 0x94, 0x86, 0xc4, 0x67, 0x43, 0x6a, 0x93, 0xfb, 0xc5, 0x7b, 0xc5, 0xca, 0x69, 0x7b, 0xe1,
	0xd3, 0x91, 0x47, 0xbc, 0xa8, 0xa6, 0x66, 0xa5, 0x6f, 0x12, 0xb0, 0x38, 0x6d, 0x46, 0xd7, 0x21,
	0x1b, 0x0a, 0xde, 0xa1, 0xf1, 0x2d, 0x97, 0xb0, 0x9d, 0xa1, 0xbb, 0x90, 0xd6, 0xb7, 0xba, 0xfc,
	0x4a, 0x06, 0x86, 0x3e, 0x85, 0x79, 0x16, 0x28, 0x2a, 0x86, 0xe4, 0x72, 0x81, 0xe2, 0x31, 0xb4,
	0xf4, 0x73, 0x02, 0x16, 0xa7, 0x73, 0x82, 0x1e, 0x42, 0x49, 0x67, 0x65, 0xd3, 0xd5, 0x39, 0x08,
	0x69, 0xd0, 0xd5, 0x9f, 0x92, 0xa0, 0x5f, 0x45, 0x54, 0xaa, 0x51, 0x22, 0xfe, 0x6d, 0x10, 0x07,
	0xe4, 0xb4, 0x19, 0xdb, 0xb1, 0x35, 0xa3, 0x8f, 0x01, 0x69, 0xd3, 0x96, 0x21, 0x8f, 0x49, 0x49,
	0x43, 0x32, 0xe5, 0x65, 0xeb, 0x80, 0x9c, 0x8e, 0xd1, 0x8f, 0xe0, 0x3f, 0xd3, 0x38, 0x37, 0xa4,
	0x62, 0x2a, 0xeb, 0xe6, 0x16, 0x19, 0x5c, 0x1c, 0x4c, 0x18, 0x4d, 0x2a, 0x26, 0xc1, 0x47, 0x37,
	0x21, 0x17, 0xd3, 0x95, 0x60, 0x34, 0x7e, 0xd9, 0x64, 0x30, 0x18, 0xb8, 0x59, 0x29, 0x7f, 0x97,
	0x84, 0xc2, 0xeb, 0x4d, 0x11, 0xdd, 0x05, 0xa4, 0xcb, 0x21, 0xf5, 0x22, 0xc5, 0x86, 0xd4, 0xa5,
	0x42, 0x70, 0x31, 0xba, 0xd7, 0xca, 0x94, 0x65, 0xcf, 0x18, 0xce, 0x85, 0x35, 0xf9, 0xce, 0x61,
	0x45, 0x4f, 0x00, 0x75, 0x88, 0xa4, 0x2e, 0x7d, 0x6e, 0x5f, 0x08, 0x26, 0x95, 0x97, 0xe6, 0xa5,
	0xa0, 0x49, 0x7b, 0x96, 0xa3, 0x25, 0x8a, 0x3e, 0x81, 0x55, 0x7d, 0xc9, 0xb1, 0x9f, 0x90, 0x0a,
	0x8f, 0x06, 0xca, 0xde, 0x16, 0x0d, 0xc8, 0xe9, 0x08, 0xde, 0x8c, 0x2d, 0x3a, 0x07, 0x03, 0x16,
	0xe8, 0x3a, 0xee, 0xab, 0xfe, 0x18, 0x9f, 0x89, 0x73, 0x30, 0x60, 0x41, 0xcd, 0x18, 0x2c, 0xba,
	0xfc, 0xa3, 0xfe, 0xf8, 0x26, 0xcd, 0x1e, 0x55, 0x21, 0x3d, 0xe0, 0xdd, 0x51, 0x6b, 0x73, 0xde,
	0xed, 0x89, 0xa0, 0xc7, 0x9a, 0x85, 0x0d, 0xd7, 0x84, 0xd8, 0x67, 0xba, 0x91, 0x79, 0x54, 0x28,
	0x76, 0xcc, 0x3c, 0xa2, 0x46, 0x0d, 0x76, 0x25, 0xb6, 0xec, 0x4c, 0x0c, 0x3a, 0x8f, 0xa1, 0x60,
	0x43, 0xa2, 0xa8, 0xae, 0x92, 0x26, 0x48, 0x0b, 0x18, 0xec, 0xd2, 0x53, 0x7a, 0xa6, 0x0b, 0x82,
	0x47, 0xa6, 0x7d, 0xc5, 0xc9, 0x5e, 0xc0, 0x79, 0x8f, 0x4c, 0x39, 0x92, 0xba, 0x03, 0xc8, 0xa8,
	0xa3, 0xe3, 0xe1, 0x12, 0x5f, 0x99, 0x1e, 0x16, 0xbf, 0x53, 0x17, 0xf0, 0xb2, 0x35, 0x6c, 0xfb,
	0x4a, 0xb7, 0x30, 0xa9, 0x9f, 0x02, 0x32, 0x60, 0xc5, 0x6c, 0xfc, 0x14, 0x90, 0x01, 0x2b, 0x3f,
	0x86, 0x6b, 0xf6, 0x1e, 0x28, 0x07, 0xd7, 0x76, 0xf7, 0x5b, 0xdb, 0xd5, 0xfa, 0x5e, 0x61, 0x4e,
	0x57, 0xe2, 0xd6, 0xfe, 0x41, 0xb3, 0xbe, 0x17, 0x57, 0xe5, 0x83, 0xa3, 0xf6, 0xd1, 0x76, 0xbd,
	0x90, 0x44, 0x05, 0x58, 0xdc, 0x6f, 0xb5, 0xf7, 0x1b, 0xae, 0x5d, 0x49, 0x55, 0x9d, 0x1f, 0x5e,
	0xad, 0x25, 0x7e, 0x7a, 0xb5, 0x96, 0xf8, 0xed, 0xd5, 0x5a, 0xe2, 0xd9, 0x7a, 0x1c, 0x3b, 0xc6,
	0x2b, 0x24, 0x64, 0x95, 0x0b, 0x7e, 0xeb, 0x3a, 0x59, 0xa3, 0x80, 0x7b, 0x7f, 0x07, 0x00, 0x00,
	0xff, 0xff, 0x4e, 0xda, 0x16, 0xb0, 0x86, 0x0e, 0x00, 0x00,
}
