// Code generated by protoc-gen-gogo.
// source: mixer/v1/config/descriptor/metric_descriptor.proto
// DO NOT EDIT!

package istio_mixer_v1_config_descriptor

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import strconv "strconv"

import strings "strings"
import reflect "reflect"
import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// The kind of measurement. It describes how the data is recorded.
type MetricDescriptor_MetricKind int32

const (
	// Do not use this default value.
	METRIC_KIND_UNSPECIFIED MetricDescriptor_MetricKind = 0
	// An instantaneous measurement of a value. For example, the number of VMs.
	GAUGE MetricDescriptor_MetricKind = 1
	// A count of occurrences over an interval, always a positive integer.
	// For example, the number of API requests.
	COUNTER MetricDescriptor_MetricKind = 2
	// Summary statistics for a population of values. At the moment, only
	// histograms representing the distribution of those values across a set of
	// buckets are supported (configured via the buckets field).
	//
	// Values for DISTRIBUTIONs will be reported in singular form. It will be up
	// to the mixer adapters and backend systems to transform single reported
	// values into the distribution form as needed (and as supported).
	DISTRIBUTION MetricDescriptor_MetricKind = 3
)

var MetricDescriptor_MetricKind_name = map[int32]string{
	0: "METRIC_KIND_UNSPECIFIED",
	1: "GAUGE",
	2: "COUNTER",
	3: "DISTRIBUTION",
}
var MetricDescriptor_MetricKind_value = map[string]int32{
	"METRIC_KIND_UNSPECIFIED": 0,
	"GAUGE":                   1,
	"COUNTER":                 2,
	"DISTRIBUTION":            3,
}

func (MetricDescriptor_MetricKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorMetricDescriptor, []int{0, 0}
}

// Defines a metric type and its schema.
//
// A metric is dimensioned by a set of labels whose values are derived at runtime
// from attributes. A given metric holds a unique value for potentially any
// combination of these dimensions.
//
// The following is an example descriptor for a metric capturing the number of
// RPCs served, dimensioned by the method being called and response code returned
// by the server:
//
// ```yaml
// metrics:
//   name: "response_count"
//   kind: COUNTER
//   value: INT64
//   labels:
//     apiMethod: STRING
//     responseCode: INT64
// ```
//
// To actually report metrics at run time a mapping from attributes to a metric's
// labels must be provided. This is provided in the aspect config; using our above
// descriptor we might describe the metric as:
//
// ```yaml
// metric:
//   descriptor: "response_count" # must match metric_descriptor.name
//   value: request.count # expression syntax for the attribute named "request.count"
//   labels:
//     # either the attribute named 'api.method' or the literal string 'unknown'; must eval to a string
//     apiMethod: api.method | "unknown"
//     # either the attribute named 'response.code' or the literal int64 500; must eval to an int64
//     responseCode: response.code | 500
// ```
//
type MetricDescriptor struct {
	// Required. The name of this descriptor. This is used to refer to this
	// descriptor in other contexts.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Optional. A concise name for the metric, which can be displayed in user
	// interfaces. Use sentence case without an ending period, for example
	// "Request count".
	DisplayName string `protobuf:"bytes,2,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	// Optional. A description of the metric, which should be used as the
	// documentation for the metric.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Required. Whether the metric records instantaneous values, changes to a
	// value, etc.
	Kind MetricDescriptor_MetricKind `protobuf:"varint,4,opt,name=kind,proto3,enum=istio.mixer.v1.config.descriptor.MetricDescriptor_MetricKind" json:"kind,omitempty"`
	// Required. The type of data this metric records.
	Value ValueType `protobuf:"varint,5,opt,name=value,proto3,enum=istio.mixer.v1.config.descriptor.ValueType" json:"value,omitempty"`
	// Labels that dimension the data recorded by this metric. The metric definition
	// allows the user to map attribute expressions to actual values for these
	// labels at run time; the result of the evaluation must be of the type described
	// by the kind for each label.
	Labels map[string]ValueType `protobuf:"bytes,6,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=istio.mixer.v1.config.descriptor.ValueType"`
	// For metrics with a metric kind of DISTRIBUTION, this provides a mechanism
	// for configuring the buckets that will be used to store the aggregated values.
	// This field must be provided for metrics declared to be of type DISTRIBUTION.
	// This field will be ignored for non-distribution metric kinds.
	Buckets *MetricDescriptor_BucketsDefinition `protobuf:"bytes,7,opt,name=buckets" json:"buckets,omitempty"`
}

func (m *MetricDescriptor) Reset()                    { *m = MetricDescriptor{} }
func (*MetricDescriptor) ProtoMessage()               {}
func (*MetricDescriptor) Descriptor() ([]byte, []int) { return fileDescriptorMetricDescriptor, []int{0} }

func (m *MetricDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MetricDescriptor) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *MetricDescriptor) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MetricDescriptor) GetKind() MetricDescriptor_MetricKind {
	if m != nil {
		return m.Kind
	}
	return METRIC_KIND_UNSPECIFIED
}

func (m *MetricDescriptor) GetValue() ValueType {
	if m != nil {
		return m.Value
	}
	return VALUE_TYPE_UNSPECIFIED
}

func (m *MetricDescriptor) GetLabels() map[string]ValueType {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *MetricDescriptor) GetBuckets() *MetricDescriptor_BucketsDefinition {
	if m != nil {
		return m.Buckets
	}
	return nil
}

type MetricDescriptor_BucketsDefinition struct {
	// Exactly one of these three fields must be set.
	//
	// Types that are valid to be assigned to Definition:
	//	*MetricDescriptor_BucketsDefinition_LinearBuckets
	//	*MetricDescriptor_BucketsDefinition_ExponentialBuckets
	//	*MetricDescriptor_BucketsDefinition_ExplicitBuckets
	Definition isMetricDescriptor_BucketsDefinition_Definition `protobuf_oneof:"definition"`
}

func (m *MetricDescriptor_BucketsDefinition) Reset()      { *m = MetricDescriptor_BucketsDefinition{} }
func (*MetricDescriptor_BucketsDefinition) ProtoMessage() {}
func (*MetricDescriptor_BucketsDefinition) Descriptor() ([]byte, []int) {
	return fileDescriptorMetricDescriptor, []int{0, 1}
}

type isMetricDescriptor_BucketsDefinition_Definition interface {
	isMetricDescriptor_BucketsDefinition_Definition()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type MetricDescriptor_BucketsDefinition_LinearBuckets struct {
	LinearBuckets *MetricDescriptor_BucketsDefinition_Linear `protobuf:"bytes,1,opt,name=linear_buckets,json=linearBuckets,oneof"`
}
type MetricDescriptor_BucketsDefinition_ExponentialBuckets struct {
	ExponentialBuckets *MetricDescriptor_BucketsDefinition_Exponential `protobuf:"bytes,2,opt,name=exponential_buckets,json=exponentialBuckets,oneof"`
}
type MetricDescriptor_BucketsDefinition_ExplicitBuckets struct {
	ExplicitBuckets *MetricDescriptor_BucketsDefinition_Explicit `protobuf:"bytes,3,opt,name=explicit_buckets,json=explicitBuckets,oneof"`
}

func (*MetricDescriptor_BucketsDefinition_LinearBuckets) isMetricDescriptor_BucketsDefinition_Definition() {
}
func (*MetricDescriptor_BucketsDefinition_ExponentialBuckets) isMetricDescriptor_BucketsDefinition_Definition() {
}
func (*MetricDescriptor_BucketsDefinition_ExplicitBuckets) isMetricDescriptor_BucketsDefinition_Definition() {
}

func (m *MetricDescriptor_BucketsDefinition) GetDefinition() isMetricDescriptor_BucketsDefinition_Definition {
	if m != nil {
		return m.Definition
	}
	return nil
}

func (m *MetricDescriptor_BucketsDefinition) GetLinearBuckets() *MetricDescriptor_BucketsDefinition_Linear {
	if x, ok := m.GetDefinition().(*MetricDescriptor_BucketsDefinition_LinearBuckets); ok {
		return x.LinearBuckets
	}
	return nil
}

func (m *MetricDescriptor_BucketsDefinition) GetExponentialBuckets() *MetricDescriptor_BucketsDefinition_Exponential {
	if x, ok := m.GetDefinition().(*MetricDescriptor_BucketsDefinition_ExponentialBuckets); ok {
		return x.ExponentialBuckets
	}
	return nil
}

func (m *MetricDescriptor_BucketsDefinition) GetExplicitBuckets() *MetricDescriptor_BucketsDefinition_Explicit {
	if x, ok := m.GetDefinition().(*MetricDescriptor_BucketsDefinition_ExplicitBuckets); ok {
		return x.ExplicitBuckets
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MetricDescriptor_BucketsDefinition) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _MetricDescriptor_BucketsDefinition_OneofMarshaler, _MetricDescriptor_BucketsDefinition_OneofUnmarshaler, _MetricDescriptor_BucketsDefinition_OneofSizer, []interface{}{
		(*MetricDescriptor_BucketsDefinition_LinearBuckets)(nil),
		(*MetricDescriptor_BucketsDefinition_ExponentialBuckets)(nil),
		(*MetricDescriptor_BucketsDefinition_ExplicitBuckets)(nil),
	}
}

func _MetricDescriptor_BucketsDefinition_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MetricDescriptor_BucketsDefinition)
	// definition
	switch x := m.Definition.(type) {
	case *MetricDescriptor_BucketsDefinition_LinearBuckets:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LinearBuckets); err != nil {
			return err
		}
	case *MetricDescriptor_BucketsDefinition_ExponentialBuckets:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ExponentialBuckets); err != nil {
			return err
		}
	case *MetricDescriptor_BucketsDefinition_ExplicitBuckets:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ExplicitBuckets); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("MetricDescriptor_BucketsDefinition.Definition has unexpected type %T", x)
	}
	return nil
}

func _MetricDescriptor_BucketsDefinition_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MetricDescriptor_BucketsDefinition)
	switch tag {
	case 1: // definition.linear_buckets
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MetricDescriptor_BucketsDefinition_Linear)
		err := b.DecodeMessage(msg)
		m.Definition = &MetricDescriptor_BucketsDefinition_LinearBuckets{msg}
		return true, err
	case 2: // definition.exponential_buckets
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MetricDescriptor_BucketsDefinition_Exponential)
		err := b.DecodeMessage(msg)
		m.Definition = &MetricDescriptor_BucketsDefinition_ExponentialBuckets{msg}
		return true, err
	case 3: // definition.explicit_buckets
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MetricDescriptor_BucketsDefinition_Explicit)
		err := b.DecodeMessage(msg)
		m.Definition = &MetricDescriptor_BucketsDefinition_ExplicitBuckets{msg}
		return true, err
	default:
		return false, nil
	}
}

func _MetricDescriptor_BucketsDefinition_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*MetricDescriptor_BucketsDefinition)
	// definition
	switch x := m.Definition.(type) {
	case *MetricDescriptor_BucketsDefinition_LinearBuckets:
		s := proto.Size(x.LinearBuckets)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MetricDescriptor_BucketsDefinition_ExponentialBuckets:
		s := proto.Size(x.ExponentialBuckets)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MetricDescriptor_BucketsDefinition_ExplicitBuckets:
		s := proto.Size(x.ExplicitBuckets)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Specifies a linear sequence of buckets that all have the same width
// (except overflow and underflow). Each bucket represents a constant
// absolute uncertainty on the specific value in the bucket.
//
// There are `num_finite_buckets + 2` (= `N`) buckets. The two additional
// buckets are the underflow and overflow buckets.
//
// Bucket `i` has the following boundaries:
//
// * Upper bound (`0 <= i < N-1`): `offset + (width * i)`
// * Lower bound (`1 <= i < N`): `offset + (width * (i - 1))`
type MetricDescriptor_BucketsDefinition_Linear struct {
	// Must be greater than 0.
	NumFiniteBuckets int32 `protobuf:"varint,1,opt,name=num_finite_buckets,json=numFiniteBuckets,proto3" json:"num_finite_buckets,omitempty"`
	// Must be greater than 0.
	Width float64 `protobuf:"fixed64,2,opt,name=width,proto3" json:"width,omitempty"`
	// Lower bound of the first bucket.
	Offset float64 `protobuf:"fixed64,3,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (m *MetricDescriptor_BucketsDefinition_Linear) Reset() {
	*m = MetricDescriptor_BucketsDefinition_Linear{}
}
func (*MetricDescriptor_BucketsDefinition_Linear) ProtoMessage() {}
func (*MetricDescriptor_BucketsDefinition_Linear) Descriptor() ([]byte, []int) {
	return fileDescriptorMetricDescriptor, []int{0, 1, 0}
}

func (m *MetricDescriptor_BucketsDefinition_Linear) GetNumFiniteBuckets() int32 {
	if m != nil {
		return m.NumFiniteBuckets
	}
	return 0
}

func (m *MetricDescriptor_BucketsDefinition_Linear) GetWidth() float64 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *MetricDescriptor_BucketsDefinition_Linear) GetOffset() float64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

// Specifies an exponential sequence of buckets that have a width that is
// proportional to the value of the lower bound. Each bucket represents a
// constant relative uncertainty on a specific value in the bucket.
//
// There are `num_finite_buckets + 2` (= `N`) buckets. The two additional
// buckets are the underflow and overflow buckets.
//
// Bucket `i` has the following boundaries:
//
// * Upper bound (0 <= i < N-1): `scale * (growth_factor ^ i)`
// * Lower bound (1 <= i < N): `scale * (growth_factor ^ (i - 1))`
type MetricDescriptor_BucketsDefinition_Exponential struct {
	// Must be greater than 0.
	NumFiniteBuckets int32 `protobuf:"varint,1,opt,name=num_finite_buckets,json=numFiniteBuckets,proto3" json:"num_finite_buckets,omitempty"`
	// Must be greater than 1.
	GrowthFactor float64 `protobuf:"fixed64,2,opt,name=growth_factor,json=growthFactor,proto3" json:"growth_factor,omitempty"`
	// Must be greater than 0.
	Scale float64 `protobuf:"fixed64,3,opt,name=scale,proto3" json:"scale,omitempty"`
}

func (m *MetricDescriptor_BucketsDefinition_Exponential) Reset() {
	*m = MetricDescriptor_BucketsDefinition_Exponential{}
}
func (*MetricDescriptor_BucketsDefinition_Exponential) ProtoMessage() {}
func (*MetricDescriptor_BucketsDefinition_Exponential) Descriptor() ([]byte, []int) {
	return fileDescriptorMetricDescriptor, []int{0, 1, 1}
}

func (m *MetricDescriptor_BucketsDefinition_Exponential) GetNumFiniteBuckets() int32 {
	if m != nil {
		return m.NumFiniteBuckets
	}
	return 0
}

func (m *MetricDescriptor_BucketsDefinition_Exponential) GetGrowthFactor() float64 {
	if m != nil {
		return m.GrowthFactor
	}
	return 0
}

func (m *MetricDescriptor_BucketsDefinition_Exponential) GetScale() float64 {
	if m != nil {
		return m.Scale
	}
	return 0
}

// Specifies a set of buckets with arbitrary widths.
//
// There are `size(bounds) + 1` (= `N`) buckets. Bucket `i` has the following
// boundaries:
//
// * Upper bound (`0 <= i < N-1`): `bounds[i]`
// * Lower bound (`1 <= i < N`): `bounds[i - 1]`
//
// The `bounds` field must contain at least one element. If `bounds` has
// only one element, then there are no finite buckets, and that single
// element is the common boundary of the overflow and underflow buckets.
type MetricDescriptor_BucketsDefinition_Explicit struct {
	// The values must be monotonically increasing.
	Bounds []float64 `protobuf:"fixed64,1,rep,packed,name=bounds" json:"bounds,omitempty"`
}

func (m *MetricDescriptor_BucketsDefinition_Explicit) Reset() {
	*m = MetricDescriptor_BucketsDefinition_Explicit{}
}
func (*MetricDescriptor_BucketsDefinition_Explicit) ProtoMessage() {}
func (*MetricDescriptor_BucketsDefinition_Explicit) Descriptor() ([]byte, []int) {
	return fileDescriptorMetricDescriptor, []int{0, 1, 2}
}

func (m *MetricDescriptor_BucketsDefinition_Explicit) GetBounds() []float64 {
	if m != nil {
		return m.Bounds
	}
	return nil
}

func init() {
	proto.RegisterType((*MetricDescriptor)(nil), "istio.mixer.v1.config.descriptor.MetricDescriptor")
	proto.RegisterType((*MetricDescriptor_BucketsDefinition)(nil), "istio.mixer.v1.config.descriptor.MetricDescriptor.BucketsDefinition")
	proto.RegisterType((*MetricDescriptor_BucketsDefinition_Linear)(nil), "istio.mixer.v1.config.descriptor.MetricDescriptor.BucketsDefinition.Linear")
	proto.RegisterType((*MetricDescriptor_BucketsDefinition_Exponential)(nil), "istio.mixer.v1.config.descriptor.MetricDescriptor.BucketsDefinition.Exponential")
	proto.RegisterType((*MetricDescriptor_BucketsDefinition_Explicit)(nil), "istio.mixer.v1.config.descriptor.MetricDescriptor.BucketsDefinition.Explicit")
	proto.RegisterEnum("istio.mixer.v1.config.descriptor.MetricDescriptor_MetricKind", MetricDescriptor_MetricKind_name, MetricDescriptor_MetricKind_value)
}
func (x MetricDescriptor_MetricKind) String() string {
	s, ok := MetricDescriptor_MetricKind_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *MetricDescriptor) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MetricDescriptor)
	if !ok {
		that2, ok := that.(MetricDescriptor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.DisplayName != that1.DisplayName {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if !this.Buckets.Equal(that1.Buckets) {
		return false
	}
	return true
}
func (this *MetricDescriptor_BucketsDefinition) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MetricDescriptor_BucketsDefinition)
	if !ok {
		that2, ok := that.(MetricDescriptor_BucketsDefinition)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Definition == nil {
		if this.Definition != nil {
			return false
		}
	} else if this.Definition == nil {
		return false
	} else if !this.Definition.Equal(that1.Definition) {
		return false
	}
	return true
}
func (this *MetricDescriptor_BucketsDefinition_LinearBuckets) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MetricDescriptor_BucketsDefinition_LinearBuckets)
	if !ok {
		that2, ok := that.(MetricDescriptor_BucketsDefinition_LinearBuckets)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.LinearBuckets.Equal(that1.LinearBuckets) {
		return false
	}
	return true
}
func (this *MetricDescriptor_BucketsDefinition_ExponentialBuckets) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MetricDescriptor_BucketsDefinition_ExponentialBuckets)
	if !ok {
		that2, ok := that.(MetricDescriptor_BucketsDefinition_ExponentialBuckets)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.ExponentialBuckets.Equal(that1.ExponentialBuckets) {
		return false
	}
	return true
}
func (this *MetricDescriptor_BucketsDefinition_ExplicitBuckets) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MetricDescriptor_BucketsDefinition_ExplicitBuckets)
	if !ok {
		that2, ok := that.(MetricDescriptor_BucketsDefinition_ExplicitBuckets)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.ExplicitBuckets.Equal(that1.ExplicitBuckets) {
		return false
	}
	return true
}
func (this *MetricDescriptor_BucketsDefinition_Linear) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MetricDescriptor_BucketsDefinition_Linear)
	if !ok {
		that2, ok := that.(MetricDescriptor_BucketsDefinition_Linear)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.NumFiniteBuckets != that1.NumFiniteBuckets {
		return false
	}
	if this.Width != that1.Width {
		return false
	}
	if this.Offset != that1.Offset {
		return false
	}
	return true
}
func (this *MetricDescriptor_BucketsDefinition_Exponential) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MetricDescriptor_BucketsDefinition_Exponential)
	if !ok {
		that2, ok := that.(MetricDescriptor_BucketsDefinition_Exponential)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.NumFiniteBuckets != that1.NumFiniteBuckets {
		return false
	}
	if this.GrowthFactor != that1.GrowthFactor {
		return false
	}
	if this.Scale != that1.Scale {
		return false
	}
	return true
}
func (this *MetricDescriptor_BucketsDefinition_Explicit) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MetricDescriptor_BucketsDefinition_Explicit)
	if !ok {
		that2, ok := that.(MetricDescriptor_BucketsDefinition_Explicit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Bounds) != len(that1.Bounds) {
		return false
	}
	for i := range this.Bounds {
		if this.Bounds[i] != that1.Bounds[i] {
			return false
		}
	}
	return true
}
func (this *MetricDescriptor) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&istio_mixer_v1_config_descriptor.MetricDescriptor{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "DisplayName: "+fmt.Sprintf("%#v", this.DisplayName)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]ValueType{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	if this.Buckets != nil {
		s = append(s, "Buckets: "+fmt.Sprintf("%#v", this.Buckets)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MetricDescriptor_BucketsDefinition) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&istio_mixer_v1_config_descriptor.MetricDescriptor_BucketsDefinition{")
	if this.Definition != nil {
		s = append(s, "Definition: "+fmt.Sprintf("%#v", this.Definition)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MetricDescriptor_BucketsDefinition_LinearBuckets) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&istio_mixer_v1_config_descriptor.MetricDescriptor_BucketsDefinition_LinearBuckets{` +
		`LinearBuckets:` + fmt.Sprintf("%#v", this.LinearBuckets) + `}`}, ", ")
	return s
}
func (this *MetricDescriptor_BucketsDefinition_ExponentialBuckets) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&istio_mixer_v1_config_descriptor.MetricDescriptor_BucketsDefinition_ExponentialBuckets{` +
		`ExponentialBuckets:` + fmt.Sprintf("%#v", this.ExponentialBuckets) + `}`}, ", ")
	return s
}
func (this *MetricDescriptor_BucketsDefinition_ExplicitBuckets) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&istio_mixer_v1_config_descriptor.MetricDescriptor_BucketsDefinition_ExplicitBuckets{` +
		`ExplicitBuckets:` + fmt.Sprintf("%#v", this.ExplicitBuckets) + `}`}, ", ")
	return s
}
func (this *MetricDescriptor_BucketsDefinition_Linear) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&istio_mixer_v1_config_descriptor.MetricDescriptor_BucketsDefinition_Linear{")
	s = append(s, "NumFiniteBuckets: "+fmt.Sprintf("%#v", this.NumFiniteBuckets)+",\n")
	s = append(s, "Width: "+fmt.Sprintf("%#v", this.Width)+",\n")
	s = append(s, "Offset: "+fmt.Sprintf("%#v", this.Offset)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MetricDescriptor_BucketsDefinition_Exponential) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&istio_mixer_v1_config_descriptor.MetricDescriptor_BucketsDefinition_Exponential{")
	s = append(s, "NumFiniteBuckets: "+fmt.Sprintf("%#v", this.NumFiniteBuckets)+",\n")
	s = append(s, "GrowthFactor: "+fmt.Sprintf("%#v", this.GrowthFactor)+",\n")
	s = append(s, "Scale: "+fmt.Sprintf("%#v", this.Scale)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MetricDescriptor_BucketsDefinition_Explicit) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&istio_mixer_v1_config_descriptor.MetricDescriptor_BucketsDefinition_Explicit{")
	s = append(s, "Bounds: "+fmt.Sprintf("%#v", this.Bounds)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringMetricDescriptor(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *MetricDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricDescriptor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetricDescriptor(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetricDescriptor(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetricDescriptor(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.Kind != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMetricDescriptor(dAtA, i, uint64(m.Kind))
	}
	if m.Value != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMetricDescriptor(dAtA, i, uint64(m.Value))
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0x32
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovMetricDescriptor(uint64(len(k))) + 1 + sovMetricDescriptor(uint64(v))
			i = encodeVarintMetricDescriptor(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMetricDescriptor(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintMetricDescriptor(dAtA, i, uint64(v))
		}
	}
	if m.Buckets != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMetricDescriptor(dAtA, i, uint64(m.Buckets.Size()))
		n1, err := m.Buckets.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *MetricDescriptor_BucketsDefinition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricDescriptor_BucketsDefinition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Definition != nil {
		nn2, err := m.Definition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	return i, nil
}

func (m *MetricDescriptor_BucketsDefinition_LinearBuckets) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LinearBuckets != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetricDescriptor(dAtA, i, uint64(m.LinearBuckets.Size()))
		n3, err := m.LinearBuckets.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *MetricDescriptor_BucketsDefinition_ExponentialBuckets) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ExponentialBuckets != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetricDescriptor(dAtA, i, uint64(m.ExponentialBuckets.Size()))
		n4, err := m.ExponentialBuckets.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *MetricDescriptor_BucketsDefinition_ExplicitBuckets) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ExplicitBuckets != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetricDescriptor(dAtA, i, uint64(m.ExplicitBuckets.Size()))
		n5, err := m.ExplicitBuckets.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *MetricDescriptor_BucketsDefinition_Linear) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricDescriptor_BucketsDefinition_Linear) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumFiniteBuckets != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetricDescriptor(dAtA, i, uint64(m.NumFiniteBuckets))
	}
	if m.Width != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64MetricDescriptor(dAtA, i, uint64(math.Float64bits(float64(m.Width))))
	}
	if m.Offset != 0 {
		dAtA[i] = 0x19
		i++
		i = encodeFixed64MetricDescriptor(dAtA, i, uint64(math.Float64bits(float64(m.Offset))))
	}
	return i, nil
}

func (m *MetricDescriptor_BucketsDefinition_Exponential) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricDescriptor_BucketsDefinition_Exponential) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumFiniteBuckets != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetricDescriptor(dAtA, i, uint64(m.NumFiniteBuckets))
	}
	if m.GrowthFactor != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64MetricDescriptor(dAtA, i, uint64(math.Float64bits(float64(m.GrowthFactor))))
	}
	if m.Scale != 0 {
		dAtA[i] = 0x19
		i++
		i = encodeFixed64MetricDescriptor(dAtA, i, uint64(math.Float64bits(float64(m.Scale))))
	}
	return i, nil
}

func (m *MetricDescriptor_BucketsDefinition_Explicit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricDescriptor_BucketsDefinition_Explicit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Bounds) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetricDescriptor(dAtA, i, uint64(len(m.Bounds)*8))
		for _, num := range m.Bounds {
			f6 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f6)
			i++
			dAtA[i] = uint8(f6 >> 8)
			i++
			dAtA[i] = uint8(f6 >> 16)
			i++
			dAtA[i] = uint8(f6 >> 24)
			i++
			dAtA[i] = uint8(f6 >> 32)
			i++
			dAtA[i] = uint8(f6 >> 40)
			i++
			dAtA[i] = uint8(f6 >> 48)
			i++
			dAtA[i] = uint8(f6 >> 56)
			i++
		}
	}
	return i, nil
}

func encodeFixed64MetricDescriptor(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32MetricDescriptor(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintMetricDescriptor(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *MetricDescriptor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetricDescriptor(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovMetricDescriptor(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMetricDescriptor(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovMetricDescriptor(uint64(m.Kind))
	}
	if m.Value != 0 {
		n += 1 + sovMetricDescriptor(uint64(m.Value))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMetricDescriptor(uint64(len(k))) + 1 + sovMetricDescriptor(uint64(v))
			n += mapEntrySize + 1 + sovMetricDescriptor(uint64(mapEntrySize))
		}
	}
	if m.Buckets != nil {
		l = m.Buckets.Size()
		n += 1 + l + sovMetricDescriptor(uint64(l))
	}
	return n
}

func (m *MetricDescriptor_BucketsDefinition) Size() (n int) {
	var l int
	_ = l
	if m.Definition != nil {
		n += m.Definition.Size()
	}
	return n
}

func (m *MetricDescriptor_BucketsDefinition_LinearBuckets) Size() (n int) {
	var l int
	_ = l
	if m.LinearBuckets != nil {
		l = m.LinearBuckets.Size()
		n += 1 + l + sovMetricDescriptor(uint64(l))
	}
	return n
}
func (m *MetricDescriptor_BucketsDefinition_ExponentialBuckets) Size() (n int) {
	var l int
	_ = l
	if m.ExponentialBuckets != nil {
		l = m.ExponentialBuckets.Size()
		n += 1 + l + sovMetricDescriptor(uint64(l))
	}
	return n
}
func (m *MetricDescriptor_BucketsDefinition_ExplicitBuckets) Size() (n int) {
	var l int
	_ = l
	if m.ExplicitBuckets != nil {
		l = m.ExplicitBuckets.Size()
		n += 1 + l + sovMetricDescriptor(uint64(l))
	}
	return n
}
func (m *MetricDescriptor_BucketsDefinition_Linear) Size() (n int) {
	var l int
	_ = l
	if m.NumFiniteBuckets != 0 {
		n += 1 + sovMetricDescriptor(uint64(m.NumFiniteBuckets))
	}
	if m.Width != 0 {
		n += 9
	}
	if m.Offset != 0 {
		n += 9
	}
	return n
}

func (m *MetricDescriptor_BucketsDefinition_Exponential) Size() (n int) {
	var l int
	_ = l
	if m.NumFiniteBuckets != 0 {
		n += 1 + sovMetricDescriptor(uint64(m.NumFiniteBuckets))
	}
	if m.GrowthFactor != 0 {
		n += 9
	}
	if m.Scale != 0 {
		n += 9
	}
	return n
}

func (m *MetricDescriptor_BucketsDefinition_Explicit) Size() (n int) {
	var l int
	_ = l
	if len(m.Bounds) > 0 {
		n += 1 + sovMetricDescriptor(uint64(len(m.Bounds)*8)) + len(m.Bounds)*8
	}
	return n
}

func sovMetricDescriptor(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMetricDescriptor(x uint64) (n int) {
	return sovMetricDescriptor(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *MetricDescriptor) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]ValueType{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&MetricDescriptor{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`DisplayName:` + fmt.Sprintf("%v", this.DisplayName) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Buckets:` + strings.Replace(fmt.Sprintf("%v", this.Buckets), "MetricDescriptor_BucketsDefinition", "MetricDescriptor_BucketsDefinition", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetricDescriptor_BucketsDefinition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MetricDescriptor_BucketsDefinition{`,
		`Definition:` + fmt.Sprintf("%v", this.Definition) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetricDescriptor_BucketsDefinition_LinearBuckets) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MetricDescriptor_BucketsDefinition_LinearBuckets{`,
		`LinearBuckets:` + strings.Replace(fmt.Sprintf("%v", this.LinearBuckets), "MetricDescriptor_BucketsDefinition_Linear", "MetricDescriptor_BucketsDefinition_Linear", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetricDescriptor_BucketsDefinition_ExponentialBuckets) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MetricDescriptor_BucketsDefinition_ExponentialBuckets{`,
		`ExponentialBuckets:` + strings.Replace(fmt.Sprintf("%v", this.ExponentialBuckets), "MetricDescriptor_BucketsDefinition_Exponential", "MetricDescriptor_BucketsDefinition_Exponential", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetricDescriptor_BucketsDefinition_ExplicitBuckets) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MetricDescriptor_BucketsDefinition_ExplicitBuckets{`,
		`ExplicitBuckets:` + strings.Replace(fmt.Sprintf("%v", this.ExplicitBuckets), "MetricDescriptor_BucketsDefinition_Explicit", "MetricDescriptor_BucketsDefinition_Explicit", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetricDescriptor_BucketsDefinition_Linear) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MetricDescriptor_BucketsDefinition_Linear{`,
		`NumFiniteBuckets:` + fmt.Sprintf("%v", this.NumFiniteBuckets) + `,`,
		`Width:` + fmt.Sprintf("%v", this.Width) + `,`,
		`Offset:` + fmt.Sprintf("%v", this.Offset) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetricDescriptor_BucketsDefinition_Exponential) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MetricDescriptor_BucketsDefinition_Exponential{`,
		`NumFiniteBuckets:` + fmt.Sprintf("%v", this.NumFiniteBuckets) + `,`,
		`GrowthFactor:` + fmt.Sprintf("%v", this.GrowthFactor) + `,`,
		`Scale:` + fmt.Sprintf("%v", this.Scale) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetricDescriptor_BucketsDefinition_Explicit) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MetricDescriptor_BucketsDefinition_Explicit{`,
		`Bounds:` + fmt.Sprintf("%v", this.Bounds) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringMetricDescriptor(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *MetricDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetricDescriptor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetricDescriptor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetricDescriptor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetricDescriptor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetricDescriptor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetricDescriptor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetricDescriptor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetricDescriptor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (MetricDescriptor_MetricKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetricDescriptor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (ValueType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetricDescriptor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetricDescriptor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetricDescriptor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetricDescriptor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthMetricDescriptor
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Labels == nil {
				m.Labels = make(map[string]ValueType)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetricDescriptor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue ValueType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetricDescriptor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapvalue |= (ValueType(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Labels[mapkey] = mapvalue
			} else {
				var mapvalue ValueType
				m.Labels[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buckets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetricDescriptor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetricDescriptor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Buckets == nil {
				m.Buckets = &MetricDescriptor_BucketsDefinition{}
			}
			if err := m.Buckets.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetricDescriptor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetricDescriptor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricDescriptor_BucketsDefinition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetricDescriptor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BucketsDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BucketsDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinearBuckets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetricDescriptor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetricDescriptor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MetricDescriptor_BucketsDefinition_Linear{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &MetricDescriptor_BucketsDefinition_LinearBuckets{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExponentialBuckets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetricDescriptor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetricDescriptor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MetricDescriptor_BucketsDefinition_Exponential{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &MetricDescriptor_BucketsDefinition_ExponentialBuckets{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExplicitBuckets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetricDescriptor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetricDescriptor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MetricDescriptor_BucketsDefinition_Explicit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &MetricDescriptor_BucketsDefinition_ExplicitBuckets{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetricDescriptor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetricDescriptor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricDescriptor_BucketsDefinition_Linear) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetricDescriptor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Linear: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Linear: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumFiniteBuckets", wireType)
			}
			m.NumFiniteBuckets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetricDescriptor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumFiniteBuckets |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Width = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Offset = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipMetricDescriptor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetricDescriptor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricDescriptor_BucketsDefinition_Exponential) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetricDescriptor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Exponential: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Exponential: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumFiniteBuckets", wireType)
			}
			m.NumFiniteBuckets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetricDescriptor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumFiniteBuckets |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrowthFactor", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.GrowthFactor = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Scale = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipMetricDescriptor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetricDescriptor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricDescriptor_BucketsDefinition_Explicit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetricDescriptor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Explicit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Explicit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.Bounds = append(m.Bounds, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetricDescriptor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMetricDescriptor
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.Bounds = append(m.Bounds, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Bounds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetricDescriptor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetricDescriptor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMetricDescriptor(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMetricDescriptor
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetricDescriptor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetricDescriptor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMetricDescriptor
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMetricDescriptor
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMetricDescriptor(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMetricDescriptor = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMetricDescriptor   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("mixer/v1/config/descriptor/metric_descriptor.proto", fileDescriptorMetricDescriptor)
}

var fileDescriptorMetricDescriptor = []byte{
	// 652 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x54, 0xc1, 0x6e, 0xd3, 0x4a,
	0x14, 0xf5, 0x24, 0x4d, 0xfa, 0x7a, 0x93, 0xf6, 0x99, 0x01, 0x41, 0x14, 0x24, 0x2b, 0x94, 0x4d,
	0xa4, 0x56, 0x8e, 0x1a, 0x36, 0x08, 0x09, 0xa4, 0xa6, 0x71, 0x5b, 0xab, 0x6d, 0x5a, 0xa6, 0x49,
	0x97, 0x58, 0x8e, 0x3d, 0x69, 0x47, 0x75, 0x6c, 0xcb, 0x9e, 0xa4, 0x0d, 0x2b, 0x24, 0x7e, 0x80,
	0x05, 0x3b, 0x7e, 0x80, 0x4f, 0x61, 0xd9, 0x25, 0x4b, 0x6a, 0x36, 0x2c, 0xfb, 0x09, 0xc8, 0x63,
	0x3b, 0x29, 0x20, 0x51, 0x51, 0x75, 0x37, 0xf7, 0xce, 0xb9, 0xe7, 0x9c, 0x7b, 0x46, 0x1a, 0x68,
	0x0e, 0xd9, 0x39, 0x0d, 0x1a, 0xe3, 0xb5, 0x86, 0xe5, 0xb9, 0x03, 0x76, 0xdc, 0xb0, 0x69, 0x68,
	0x05, 0xcc, 0xe7, 0x5e, 0xd0, 0x18, 0x52, 0x1e, 0x30, 0xcb, 0x98, 0x75, 0x54, 0x3f, 0xf0, 0xb8,
	0x87, 0x6b, 0x2c, 0xe4, 0xcc, 0x53, 0xc5, 0xa4, 0x3a, 0x5e, 0x53, 0x93, 0x49, 0x75, 0x86, 0xab,
	0xae, 0xfc, 0x85, 0x75, 0x6c, 0x3a, 0x23, 0x6a, 0xf0, 0x89, 0x4f, 0x13, 0xba, 0xe5, 0x8f, 0x00,
	0xf2, 0x9e, 0x90, 0x6a, 0x4f, 0x51, 0x18, 0xc3, 0x9c, 0x6b, 0x0e, 0x69, 0x05, 0xd5, 0x50, 0x7d,
	0x81, 0x88, 0x33, 0x7e, 0x02, 0x65, 0x9b, 0x85, 0xbe, 0x63, 0x4e, 0x0c, 0x71, 0x97, 0x13, 0x77,
	0xa5, 0xb4, 0xd7, 0x89, 0x21, 0x35, 0x28, 0x65, 0x52, 0xcc, 0x73, 0x2b, 0xf9, 0x14, 0x31, 0x6b,
	0xe1, 0xd7, 0x30, 0x77, 0xca, 0x5c, 0xbb, 0x32, 0x57, 0x43, 0xf5, 0xa5, 0xe6, 0x4b, 0xf5, 0xa6,
	0x5d, 0xd4, 0xdf, 0xad, 0xa5, 0x8d, 0x1d, 0xe6, 0xda, 0x44, 0x50, 0xe1, 0x75, 0x28, 0x88, 0xa5,
	0x2a, 0x05, 0xc1, 0xb9, 0x72, 0x33, 0xe7, 0x51, 0x0c, 0xef, 0x4e, 0x7c, 0x4a, 0x92, 0x49, 0x7c,
	0x04, 0x45, 0xc7, 0xec, 0x53, 0x27, 0xac, 0x14, 0x6b, 0xf9, 0x7a, 0xa9, 0xf9, 0xea, 0x16, 0xbe,
	0x76, 0x05, 0x81, 0xe6, 0xf2, 0x60, 0x42, 0x52, 0x36, 0xfc, 0x06, 0xe6, 0xfb, 0x23, 0xeb, 0x94,
	0xf2, 0xb0, 0x32, 0x5f, 0x43, 0xf5, 0x52, 0xb3, 0x7d, 0x0b, 0xe2, 0x56, 0xc2, 0xd0, 0xa6, 0x03,
	0xe6, 0xb2, 0x38, 0x44, 0x92, 0x91, 0x56, 0x07, 0x50, 0xba, 0x26, 0x8b, 0x65, 0xc8, 0x9f, 0xd2,
	0x49, 0xfa, 0x68, 0xf1, 0x71, 0x96, 0x4d, 0xee, 0xb6, 0xd9, 0xbc, 0xc8, 0x3d, 0x47, 0xd5, 0x4f,
	0x05, 0xb8, 0xf7, 0x87, 0x0d, 0xcc, 0x61, 0xc9, 0x61, 0x2e, 0x35, 0x03, 0x23, 0x5b, 0x12, 0x89,
	0x25, 0x77, 0xee, 0x62, 0x49, 0x75, 0x57, 0x50, 0x6f, 0x4b, 0x64, 0x31, 0x11, 0x49, 0x11, 0xf8,
	0x3d, 0x82, 0xfb, 0xf4, 0xdc, 0xf7, 0x5c, 0xea, 0x72, 0x66, 0x3a, 0x53, 0xed, 0x9c, 0xd0, 0x3e,
	0xb8, 0x13, 0x6d, 0x6d, 0xc6, 0xbf, 0x2d, 0x11, 0x7c, 0x4d, 0x2e, 0x73, 0xf1, 0x16, 0x64, 0x7a,
	0xee, 0x3b, 0xcc, 0x62, 0x7c, 0xea, 0x20, 0x2f, 0x1c, 0xec, 0xdd, 0x95, 0x03, 0x41, 0xbe, 0x2d,
	0x91, 0xff, 0x33, 0xa1, 0x14, 0x55, 0xb5, 0xa1, 0x98, 0x84, 0x83, 0x57, 0x01, 0xbb, 0xa3, 0xa1,
	0x21, 0xa6, 0xe8, 0x2f, 0xaf, 0x50, 0x20, 0xb2, 0x3b, 0x1a, 0x6e, 0x8a, 0x8b, 0xcc, 0xf3, 0x03,
	0x28, 0x9c, 0x31, 0x9b, 0x9f, 0x88, 0xa8, 0x10, 0x49, 0x0a, 0xfc, 0x10, 0x8a, 0xde, 0x60, 0x10,
	0x52, 0x2e, 0xfc, 0x23, 0x92, 0x56, 0xd5, 0x31, 0x94, 0xae, 0xc5, 0xf0, 0x8f, 0x52, 0x4f, 0x61,
	0xf1, 0x38, 0xf0, 0xce, 0xf8, 0x89, 0x31, 0x30, 0x2d, 0xee, 0x05, 0xa9, 0x64, 0x39, 0x69, 0x6e,
	0x8a, 0x5e, 0xec, 0x27, 0xb4, 0x4c, 0x87, 0xa6, 0xc2, 0x49, 0x51, 0x5d, 0x86, 0xff, 0xb2, 0xe5,
	0x63, 0x6f, 0x7d, 0x6f, 0xe4, 0xda, 0xb1, 0x50, 0x3e, 0xf6, 0x96, 0x54, 0xad, 0x32, 0x80, 0x3d,
	0xcd, 0x6a, 0xf9, 0x10, 0x60, 0xf6, 0x29, 0xe0, 0xc7, 0xf0, 0x68, 0x4f, 0xeb, 0x12, 0x7d, 0xc3,
	0xd8, 0xd1, 0x3b, 0x6d, 0xa3, 0xd7, 0x39, 0x3c, 0xd0, 0x36, 0xf4, 0x4d, 0x5d, 0x6b, 0xcb, 0x12,
	0x5e, 0x80, 0xc2, 0xd6, 0x7a, 0x6f, 0x4b, 0x93, 0x11, 0x2e, 0xc1, 0xfc, 0xc6, 0x7e, 0xaf, 0xd3,
	0xd5, 0x88, 0x9c, 0xc3, 0x32, 0x94, 0xdb, 0xfa, 0x61, 0x97, 0xe8, 0xad, 0x5e, 0x57, 0xdf, 0xef,
	0xc8, 0xf9, 0xd6, 0xea, 0xc5, 0xa5, 0x22, 0x7d, 0xbd, 0x54, 0xa4, 0xab, 0x4b, 0x05, 0xbd, 0x8b,
	0x14, 0xf4, 0x39, 0x52, 0xd0, 0x97, 0x48, 0x41, 0x17, 0x91, 0x82, 0xbe, 0x45, 0x0a, 0xfa, 0x11,
	0x29, 0xd2, 0x55, 0xa4, 0xa0, 0x0f, 0xdf, 0x15, 0xa9, 0x5f, 0x14, 0x7f, 0xe9, 0xb3, 0x9f, 0x01,
	0x00, 0x00, 0xff, 0xff, 0xaa, 0x48, 0x7f, 0x0c, 0xd0, 0x05, 0x00, 0x00,
}
