diff --git a/cni/pkg/nodeagent/server.go b/cni/pkg/nodeagent/server.go
index 5839c72ad6..568c9ca0c1 100644
--- a/cni/pkg/nodeagent/server.go
+++ b/cni/pkg/nodeagent/server.go
@@ -26,6 +26,7 @@ import (
 	"k8s.io/apimachinery/pkg/api/errors"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/client-go/rest"
+	"k8s.io/component-helpers/scheduling/corev1/nodeaffinity"
 
 	"istio.io/istio/cni/pkg/scopes"
 	"istio.io/istio/pkg/kube"
@@ -139,12 +140,36 @@ func (s *Server) ShouldStopCleanup(selfName, selfNamespace string, istioOwnedCNI
 			cniDS, err := s.kubeClient.Kube().AppsV1().DaemonSets(selfNamespace).Get(context.Background(), dsName, metav1.GetOptions{})
 
 			if err == nil && cniDS != nil && cniDS.DeletionTimestamp == nil {
+				cniNode, err := s.kubeClient.Kube().CoreV1().Nodes().Get(context.Background(), NodeName, metav1.GetOptions{})
+				if err != nil {
+					log.Infof("failed to get CNI node %s, retrying: %v", NodeName, err)
+					return err
+				}
+
+				if cniDS.Spec.Template.Spec.Affinity != nil &&
+					cniDS.Spec.Template.Spec.Affinity.NodeAffinity != nil &&
+					cniDS.Spec.Template.Spec.Affinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution != nil {
+					nodeSelector, err := nodeaffinity.NewNodeSelector(cniDS.Spec.Template.Spec.Affinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution)
+					if err != nil {
+						log.Infof("failed to build NodeSelector for DaemonSet %s, retrying: %v", dsName, err)
+						return err
+					}
+
+					if !nodeSelector.Match(cniNode) {
+						// If the NodeAffinity of the DaemonSet no longer matches the current Node, this is not an upgrade.
+						// We can safely shut down the plugin.
+						log.Infof("terminating, and parent DaemonSet %s will not schedule to Node %s due to NodeAffinity rules, shutting down normally", dsName, NodeName)
+						shouldStopCleanup = false
+						return nil
+					}
+				}
+
 				log.Infof("terminating, but parent DaemonSet %s is still present, this is an upgrade or a node reboot, leaving plugin in place", dsName)
 				shouldStopCleanup = true
 				return nil
 			}
 			if errors.IsNotFound(err) || (cniDS != nil && cniDS.DeletionTimestamp != nil) {
-				// If the DS is gone, or marked for deletion, this is not an upgrade.
+				// If the DaemonSet is gone, or marked for deletion, this is not an upgrade.
 				// We can safely shut down the plugin.
 				log.Infof("parent DaemonSet %s is not found or marked for deletion, this is not an upgrade, shutting down normally", dsName)
 				shouldStopCleanup = false
@@ -156,7 +181,7 @@ func (s *Server) ShouldStopCleanup(selfName, selfNamespace string, istioOwnedCNI
 				shouldStopCleanup = false
 				return nil
 			}
-			log.Infof("failed to get parent DS %s, retrying: %v", dsName, err)
+			log.Infof("failed to get parent DaemonSet %s, retrying: %v", dsName, err)
 			return err
 		},
 		// Limiting retries to 3 so other shutdown tasks can complete before the graceful shutdown period ends
diff --git a/go.mod b/go.mod
index 533451d45f..1e0374c58c 100644
--- a/go.mod
+++ b/go.mod
@@ -102,6 +102,7 @@ require (
 	k8s.io/apiserver v0.35.0
 	k8s.io/cli-runtime v0.35.0
 	k8s.io/client-go v0.35.0
+	k8s.io/component-helpers v0.35.0
 	k8s.io/klog/v2 v2.130.1
 	k8s.io/kubectl v0.35.0
 	k8s.io/utils v0.0.0-20251219084037-98d557b7f1e7
@@ -226,7 +227,6 @@ require (
 	gopkg.in/evanphx/json-patch.v4 v4.13.0 // indirect
 	gopkg.in/inf.v0 v0.9.1 // indirect
 	k8s.io/component-base v0.35.0 // indirect
-	k8s.io/component-helpers v0.35.0 // indirect
 	k8s.io/kube-openapi v0.0.0-20251125145642-4e65d59e963e // indirect
 	sigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.32.1 // indirect
 	sigs.k8s.io/json v0.0.0-20250730193827-2d320260d730 // indirect
diff --git a/releasenotes/notes/58768.yaml b/releasenotes/notes/58768.yaml
new file mode 100644
index 0000000000..f3c335117d
--- /dev/null
+++ b/releasenotes/notes/58768.yaml
@@ -0,0 +1,9 @@
+apiVersion: release-notes/v2
+kind: bug-fix
+area: installation
+issue:
+  - 58768
+releaseNotes:
+  - |
+    **Fixed** an issue where the `istio-cni` daemonSet treated NodeAffinity changes as upgrades,
+    causing CNI config to be incorrectly left in place when a node no longer matched the DaemonSet's NodeAffinity rules.
